<?xml version="1.0" encoding="utf-8"?>
<Project
    xmlns="http://schemas.microsoft.com/developer/msbuild/2003"
    ToolsVersion="12.0">

  <!-- This is a custom version which resolves an ArgumentOutOfRangeException -->
  <UsingTask TaskName="RidoTasks.trx2html" AssemblyFile="$(BuildScriptsDirectory)\Build\Tasks\RidoTasks.dll" />

  <!-- 
    =========================================================================================================
        Team Build Script - Workflow Prototype                                                         
        
        Guidelines:            
            * Retain structure and formatting for easier merge between Team Build project scripts 
            * Tabs converted to 4 spaces for easier reading outside of VS.
    =========================================================================================================
    -->

  <ProjectExtensions>
    <ProjectFileVersion>4</ProjectFileVersion>
  </ProjectExtensions>

  <PropertyGroup>
      <BuildScriptsDirectory>$(SolutionRoot)</BuildScriptsDirectory>
    
      <!-- Detect Visual Studio Versions -->
      <VsCommonTools Condition="'$(VS100COMNTOOLS)' != ''">$(VS100COMNTOOLS)</VsCommonTools>
      <VsCommonTools Condition="'$(VS110COMNTOOLS)' != ''">$(VS110COMNTOOLS)</VsCommonTools>
      <VsCommonTools Condition="'$(VS120COMNTOOLS)' != ''">$(VS120COMNTOOLS)</VsCommonTools>
  </PropertyGroup>
  
  <!--
    ==========================================================================================
        Build Status - Set both Build and Step status to FAIL
    ==========================================================================================
  -->

  <Target Name="MarkBuildStepAsFailed">
    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Failed" />
    <SetBuildProperties
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      CompilationStatus="Failed" />
    <Error Condition="('$(IsDesktopBuild)'=='true')"/>
  </Target>

  
  <!--
    ==========================================================================================
        Build Status - Only set Step status to FAIL
    ==========================================================================================
  -->
  
  <Target Name="MarkStepAsFailed">
    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Failed" />
    <Error Condition="('$(IsDesktopBuild)'=='true')"/>
  </Target>


  <!--
    ==========================================================================================
        Set up common packaging properties.
    ==========================================================================================
  -->

  <Target Name="CommonPackagingProperties">
    <PropertyGroup>
      <ExpertProductDropDirectory>$(DropLocation)\$(BuildNumber)</ExpertProductDropDirectory>
      <!--Local for factory generation-->
      <LocalExpertBinariesDirectory>$(SolutionRoot)\..\ExpertBinaries</LocalExpertBinariesDirectory>
      <DropExpertBinariesDirectory>$(ExpertProductDropDirectory)\ExpertBinaries</DropExpertBinariesDirectory>
      <!--Drop directories that we will copy too NB: BuildNumber is not set if this property is created outside the target.-->
      <DropExpertTestsDirectory>$(ExpertProductDropDirectory)\TestingBinaries</DropExpertTestsDirectory>
      <!--Copy test binaries, and run tests from this location.-->
      <ExpertTestsDirectory>$(SolutionRoot)\..\TestBinaries</ExpertTestsDirectory>
    </PropertyGroup>
  </Target>

  <!--
    ==========================================================================================
        GetProduct to Target Machine
    ==========================================================================================
  -->
  <Target Name="GetProduct"
          DependsOnTargets="CommonPackagingProperties" >

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Get Product from $(ExpertModulesDirectory) to $(RemoteExpertSourceDirectory)"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>
    
    <Exec ContinueOnError="false"
          IgnoreExitCode="false"
          Command='"Powershell" "$(BuildScriptsDirectory)\GetProduct.ps1" -productManifestPath $(ProductManifestPath) -dropRoot $(ExpertModulesDirectory) -binariesDirectory $(RemoteExpertSourceDirectory) -getDebugFiles $false -buildLibrariesPath $(BuildScriptsDirectory) -systemMapConnectionString {"$(ExpertDatabaseConnectionStringForSystemMap)"}'
          WorkingDirectory="$(BuildScriptsDirectory)" />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />
  </Target>

  <!--
    ==========================================================================================
        GetProductZip to Target Machine
    ==========================================================================================
  -->
  <Target Name="GetProductZip"
          DependsOnTargets="CommonPackagingProperties" >

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Get Product Zip from $(ExpertModulesDirectory) to $(RemoteExpertSourceDirectory)"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>

    <!--Merge and generate factory.bin-->
    <Exec ContinueOnError="false"
          IgnoreExitCode="false"
          Command='"Powershell" "$(BuildScriptsDirectory)\GetProductZip.ps1" -remoteMachineName $(RemoteTestMachineName) -dropRoot $(ExpertModulesDirectory) -binariesDirectory $(LocalExpertBinariesPathOnRemote) -buildLibrariesPath $(BuildScriptsDirectory)'
          WorkingDirectory="$(BuildScriptsDirectory)" />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />
  </Target>
  
  <!--
    ==========================================================================================
        Package The Product Tests
    ==========================================================================================
  -->
  <Target Name="PackageProductTests"
          DependsOnTargets="CommonPackagingProperties" >

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Package Product Tests"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>


    <!-- Clear test directory. -->
    <RemoveDir Directories="$(ExpertTestsDirectory)" Condition="Exists('$(ExpertTestsDirectory)')"/>
    <MakeDir Directories="$(ExpertTestsDirectory)" Condition="!Exists('$(ExpertTestsDirectory)')" />

    <!--Copy test binaries to folder for execution.-->
    <Exec ContinueOnError="false"
          IgnoreExitCode="false"
          Command='"Powershell" "$(BuildScriptsDirectory)\GetProductTests.ps1" -buildSourcesDirectory $(SolutionRoot) -productManifestPath $(ProductManifestPath) -dropRoot $(ExpertModulesDirectory) -binariesDirectory $(ExpertTestsDirectory) -buildLibrariesPath $(BuildScriptsDirectory)'
          WorkingDirectory="$(BuildScriptsDirectory)" />

    <!--Copy to drop location for reference-->
    <!-- Andy - we are hitting 260 char limit so commenting this out to test a build.-->
    <!--<MakeDir Directories="$(DropExpertTestsDirectory)" Condition="!Exists('$(DropExpertTestsDirectory)')" />
        <Exec ContinueOnError="false"
              IgnoreExitCode="false"
              Command='"Powershell" Copy-Item -Path $(ExpertTestsDirectory)\* -Destination $(DropExpertTestsDirectory) -Recurse' />-->

    <BuildStep
            Condition="('$(IsDesktopBuild)'!='true')"
            TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
            BuildUri="$(BuildUri)"
            Id="$(BuildStepId)"
            Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />

  </Target>
  
  <!--
    ==========================================================================================
        Move all ordered tests to the test directory
    ==========================================================================================
  -->
  <Target Name="ParseOrderedTests" >

    <BuildStep
          Condition="('$(IsDesktopBuild)'!='true')"
          Message="Parse all Ordered Test Files"
          TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
          BuildUri="$(BuildURI)">
      <Output TaskParameter="id"
              PropertyName="BuildStepId" />
    </BuildStep>
    
    <PropertyGroup>
      <TestAssemblyDirectory>$([System.IO.Path]::GetFullPath('$(ExpertTestsDirectory)\ExpertSource'))</TestAssemblyDirectory>
    </PropertyGroup>
    <Exec
      ContinueOnError="false"
      IgnoreExitCode="false"
      Command='"Powershell" "$(BuildScriptsDirectory)\ParseOrderedTests.ps1" $(TestAssemblyDirectory)' />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />

  </Target>
  
  <!--
    ==========================================================================================
        Remove the deployed Product
    ==========================================================================================
  -->
  <Target Name="RemoveProduct" >

    <BuildStep
          Condition="('$(IsDesktopBuild)'!='true')"
          Message="Remove the deployed Product"
          TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
          BuildUri="$(BuildURI)">
      <Output TaskParameter="id"
              PropertyName="BuildStepId" />
    </BuildStep>
    
    <Exec
      ContinueOnError="false"
      IgnoreExitCode="false"
      Command='"Powershell" "$(BuildScriptsDirectory)\DeploymentRemove.ps1" $(LocalExpertBinariesDirectory) $(EnvironmentManifestPath) $(RemoteTestMachineName)' />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />

  </Target>
  
  <!--
    ==========================================================================================
        Run remote deployment from remote machine
    ==========================================================================================
  -->
  <Target Name="RemoveProductRemote" >

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Remove the deployed Product"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>

    <Error Condition="'$(RemoteTestMachineName)' == ''" Text="RemoteTestMachineName is not specified" />
    
    <Exec
      ContinueOnError="false"
      IgnoreExitCode="false"
      Command='"Powershell" "$(BuildScriptsDirectory)\RemoteDeploymentRemove.ps1" $(RemoteTestMachineName) $(EnvironmentManifestPath)' />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />

  </Target>

  <!--
    
    ==========================================================================================
        Restore Database
    ==========================================================================================
  -->

  <Target Name="RestoreDB"
            Condition="('$(IsDesktopBuild)' != 'true') and ('$(RestoreDatabase)' == 'true')">

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Restoring Database"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>
    
    <PropertyGroup>
      <DatabaseBackupLocation>\\$(MachineName)\$(BuildDirectory.Replace(':','$'))\Database.bak</DatabaseBackupLocation>
    </PropertyGroup>
    <Exec
      ContinueOnError="false"
      IgnoreExitCode="false"
      Command='"Powershell" "$(BuildScriptsDirectory)\RestoreDB.ps1" $(EnvironmentManifestPath) $(DatabaseBackupLocation)' />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />

  </Target>

  <!--    
    ==========================================================================================
        Deploy the database project.
        Include the following parameter in your rsp to deploy the database project
            /p:DeployDbProject=true
    ==========================================================================================
  -->

  <Target Name="DeployDatabaseProject"
          Condition="('$(IsDesktopBuild)' != 'true') and ('$(DeployDbProject)' == 'true')" >

    <BuildStep
      Condition="('$(IsDesktopBuild)' != 'true')"
      Message="Deploying database project"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>

    <!--    Need to make this a PS script that runs this command remotely on test machine as that
                is where the db schema file is.
                -->
    <Exec
            ContinueOnError="false"
            IgnoreExitCode="false"
            Command='"C:\Program Files (x86)\Microsoft Visual Studio 10.0\VSTSDB\Deploy\vsdbcmd.exe" /a:deploy /dd /cs:"Integrated Security=SSPI;Initial Catalog=$(DbProjectTargetDatabase);Data Source=$(DbProjectTargetServer)" /ManifestFile:$(DbProjectSchemaFilePath) /dsp:sql /p:TargetDatabase="$(DbProjectTargetDatabase)" /p:BlockIncrementalDeploymentIfDataLoss=False /p:DeployDatabaseProperties=False /p:AlwaysCreateNewDatabase=false' />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />

  </Target>

  <!--  
    
    ==========================================================================================
        Deploy the Product
    ==========================================================================================
  -->

  <Target Name="DeployProduct" >

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Deploying Product"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output TaskParameter="id"
              PropertyName="BuildStepId" />
    </BuildStep>

    
    <Exec
            ContinueOnError="false"
            IgnoreExitCode="false"
            Command='"Powershell" "$(BuildScriptsDirectory)\DeploymentDeploy.ps1" $(LocalExpertBinariesDirectory) $(EnvironmentManifestPath)' />

    <BuildStep
            Condition="('$(IsDesktopBuild)'!='true')"
            TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
            BuildUri="$(BuildUri)"
            Id="$(BuildStepId)"
            Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />

  </Target>

  <!--
    ==========================================================================================
        Run deployment from remote machine
    ==========================================================================================
  -->
  <Target Name="DeployProductRemote">
    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Deploying Product"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>

    <Error Condition="'$(RemoteTestMachineName)' == ''" Text="RemoteTestMachineName is not specified" />

    <Exec
      ContinueOnError="false"
      IgnoreExitCode="false"
      Command='"Powershell" "$(BuildScriptsDirectory)\RemoteDeploymentDeploy.ps1" $(RemoteTestMachineName) $(EnvironmentManifestPath) $$(DeployExpert)' />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />
  </Target>

  <!--
    ==========================================================================================
        Wait & Check that Services have started
    ==========================================================================================
  -->
  <Target Name="WaitForServiceStartUp">

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Testing services have started"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>

    <Exec ContinueOnError="false"
          IgnoreExitCode="false"
          Command='"Powershell" "$(BuildScriptsDirectory)\PingDeploymentEngine.ps1" $(RemoteTestMachineName) $(EnvironmentManifestPath)' />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />

  </Target>

  <!--
    ==========================================================================================
        Integration Tests
    ==========================================================================================
  -->
  <Target Name="IntegrationTests"
          DependsOnTargets="CommonPackagingProperties"
          Condition="('$(RunTests)'=='true')" >

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Running Integration Tests"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>

    <PropertyGroup>
      <TestAssemblyDirectory>$([System.IO.Path]::GetFullPath('$(ExpertTestsDirectory)\ExpertSource'))</TestAssemblyDirectory>
      <!-- VSTest Setup -->
      <VsTestDirectory>$(VsCommonTools)..\IDE\CommonExtensions\Microsoft\TestWindow</VsTestDirectory>
      <PathToTestTool>$(VsTestDirectory)\vstest.console.exe</PathToTestTool>
      <PathToTfsLogger>$(VsTestDirectory)\Extensions\Microsoft.VisualStudio.TestPlatform.Extensions.TfsLogger.dll</PathToTfsLogger>
      <IsolationSwitch></IsolationSwitch>
      <!-- Test result publishing requires Visual Studio Update 1 or higher -->
      <LoggerSwitch>/logger:Multicast;loggers=trx,TfsPublisher;TfsPublisher.Collection=$(TeamFoundationServerUrl);TfsPublisher.BuildName=$(BuildNumber);TfsPublisher.TeamProject=$(TeamProject);TfsPublisher.Platform="%(ConfigurationToBuild.PlatformToBuild)";TfsPublisher.Flavor="%(ConfigurationToBuild.FlavorToBuild)"</LoggerSwitch>
      <TestSettingsSwitch>/Settings:$(TestSettingsFile)</TestSettingsSwitch>
      <TestFilterSwitch>$(TestCaseFilterSwitch)</TestFilterSwitch>
    </PropertyGroup>

    <Message Text="Test Assembly Directory: $(TestAssemblyDirectory)" />
    <Message Text="Excluding test assemblies: $(ExcludeIntegrationAssemblies)" />
   
    <!--Expand the scalar property from the command line into an item group -->
    <ItemGroup>
      <ExcludedIntegrationAssemblies Include="$(ExcludeIntegrationAssemblies)" />
    </ItemGroup>
    
    <Message Text="Exclude List: @(ExcludedIntegrationAssemblies)" />
    
    <PropertyGroup>
        <TestAssemblyIncludePattern Condition="'$(TestAssemblyIncludePattern)' == ''">IntegrationTest*.dll</TestAssemblyIncludePattern>
    </PropertyGroup>

    <ItemGroup>
      <PatternGroup Include="$(TestAssemblyIncludePattern.Split(';'))"  />
    </ItemGroup>

    <!--
    <ItemGroup>
      <IntegrationAssemblies Include="$(TestAssemblyDirectory)\$(TestAssemblyIncludePattern)"
                             Exclude="@(ExcludedIntegrationAssemblies->'$(TestAssemblyDirectory)\%(Filename)%(Extension)')" />
    </ItemGroup>
    -->
    
    <!--Changed the integration assembly construction to CreatItem as this resolves wildcards as strings.  This lets us pass in multiple wildcard expressions-->
    <CreateItem Include="$(TestAssemblyDirectory)\%(PatternGroup.Identity)" 
                Exclude="@(ExcludedIntegrationAssemblies-> '$(TestAssemblyDirectory)\%(Filename)%(Extension)')" >
      <Output TaskParameter="Include" ItemName="IntegrationAssemblies" />
    </CreateItem>

    <PropertyGroup>
      <!-- Create a space delimited string -->
      <TestAssemblies>@(IntegrationAssemblies->'&quot;%(FullPath)&quot;',' ')</TestAssemblies>
    </PropertyGroup>

    <Message Text="Test Assemblies: $(TestAssemblies)" />

    <!-- Group of integration assemblies, excludes automation test assemblies-->
    <ItemGroup>
      <IntegrationTestToChange Include="$(TestAssemblyDirectory)\IntegrationTest*.dll"
                               Exclude="@(ExcludedIntegrationAssemblies->'$(TestAssemblyDirectory)\%(Filename)%(Extension)')"  />
    </ItemGroup>

    <Message Text="Integration Assemblies: $(IntegrationTestToChange)" />
    <Message Text="Replacing test configuration files with template from: $(BuildDirectory)" />

    <!-- Foreach integration test assembly, replace the checked in .config with our template
         Excludes automation assemblies -->
    <Copy SourceFiles="$(BuildDirectory)\IntegrationTest.config" 
          DestinationFiles="%(IntegrationTestToChange.FullPath).config"
          OverwriteReadOnlyFiles="true" />
    
    <!-- 
      Copy the assembly that gives us multicast logging into the test directory .
      For some reason the designers of VSTest decided you only want to log to one output.
    -->
    <PropertyGroup>
      <TeamCityLogger Condition="'$(TeamCityLogger)'==''">$(VsTestDirectory)\Extensions\VSTest.TeamCityLogger.dll</TeamCityLogger>
    </PropertyGroup>
    
    <Copy SourceFiles="$(BuildScriptsDirectory)\Build\Tasks\VSTest.TeamCityLogger.dll" 
          DestinationFiles="$(TeamCityLogger)"
          Condition="!Exists('$(TeamCityLogger)')" />

    <!-- Run the integration tests -->
    <Exec Command='"$(PathToTestTool)" $(TestAssemblies) $(TestSettingsSwitch) $(TestFilterSwitch) $(LoggerSwitch) $(IsolationSwitch)'
          ContinueOnError="false"
          IgnoreExitCode="false" 
          WorkingDirectory="$(TestAssemblyDirectory)" />
    
    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkStepAsFailed; ConvertTestResults" />
  </Target>

  <!--
    ==========================================================================================
        Convert Integration Test Result to HTML
    ==========================================================================================
  -->		
  <Target Name="ConvertTestResults"
          Condition="('$(RunTests)'=='true')" >
    
    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Converting Integration Tests Results to HTML"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>
    
    <Error Condition="'$(TestAssemblyDirectory)' == ''" Text="TestAssemblyDirectory is empty" />

    <ItemGroup>
      <TestResults Include="$(TestAssemblyDirectory)\TestResults\*.trx" />
    </ItemGroup>

    <Message Text="Copying TRX file to drop $(DropLocation)\$(BuildNumber)" />
    <Copy SourceFiles="@(TestResults)"
          DestinationFolder="$(DropLocation)\$(BuildNumber)" />

    <ItemGroup>
      <TestResults Include="$(DropLocation)\$(BuildNumber)\*.trx" />
    </ItemGroup>
    
    <RidoTasks.trx2html FileName="%(TestResults.FullPath)" />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkStepAsFailed" />
    
  </Target>

  <!--  
    ==========================================================================================
        Apply UPD
    ==========================================================================================
  -->
  <Target Name="ApplyUPD"
          Condition="('$(IsDesktopBuild)' != 'true') and ('$(RunUPD)' == 'true')">

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Running UPD"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>

    <Exec
     ContinueOnError="false"
     IgnoreExitCode="false"
     Command='"Powershell" "$(BuildScriptsDirectory)\AllowDotNet40Assemblies.ps1"' />
    
    <Exec
      ContinueOnError="false"
      IgnoreExitCode="false"
      Command='"Powershell" "$(BuildScriptsDirectory)\DeployDatabase.ps1" $(EnvironmentManifestPath) $(RemoteExpertSourceDirectory)\ExpertSource' />

    
    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />

  </Target>

</Project>
