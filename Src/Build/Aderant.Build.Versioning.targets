<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!--
  There are at least 2 AssemblyInfo.cs files involved.
  1) \<Temp>\CommonAssemblyInfoFile.cs    = A clone of CommonAssemblyInfoFile.cs with the copyright date modified (subject to race condition)
  2) \<Temp>\CommonAssemblyInfoFile.g.cs  = Repository metadata file (git version etc)
  -->

  <PropertyGroup>
    <SetVersionAttributesDependsOn Condition="'$(IsCustomBuild)' != 'true' And '$(ProjectGuid)' != ''">
      $(SetVersionAttributesDependsOn);
      UpdateCommonAssemblyInfo;
    </SetVersionAttributesDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <SetVersionAttributesBeforeTargets Condition="'$(Language)' == 'C#'">
      BeforeCompile
    </SetVersionAttributesBeforeTargets>
  </PropertyGroup>

  <!-- Stub that lets us hook BeforeCompile without breaking others that also override BeforeCompile -->
  <Target Name="SetVersionAttributes" BeforeTargets="$(PrepareResourcesDependsOn);$(SetVersionAttributesBeforeTargets)" DependsOnTargets="$(SetVersionAttributesDependsOn)" />


  <PropertyGroup>
    <CreateGeneratedAssemblyInfoInputsDependsOn>
      GatherCommonAssemblyAttributes;
      GatherProjectAssemblyAttributes;
      FindRoleFiles;
    </CreateGeneratedAssemblyInfoInputsDependsOn>
  </PropertyGroup>


  <Target Name="GatherProjectAssemblyAttributes">
    <PropertyGroup>
      <IsIntegrationTest Condition="$(MSBuildProjectName.StartsWith('IntegrationTest')) And !($(MSBuildProjectName.EndsWith('Helper')) Or $(MSBuildProjectName.EndsWith('Helpers')))">true</IsIntegrationTest>
      <IsIntegrationTest Condition="'$(IsIntegrationTest)' == ''">false</IsIntegrationTest>

      <IsIntegrationTestHelper Condition="$(MSBuildProjectName.StartsWith('IntegrationTest')) And ($(MSBuildProjectName.EndsWith('Helper')) Or $(MSBuildProjectName.EndsWith('Helpers')))">true</IsIntegrationTestHelper>
      <IsIntegrationTestHelper Condition="'$(IsIntegrationTestHelper)' == ''">false</IsIntegrationTestHelper>

      <CIEnabled Condition="'$(IsIntegrationTest)' == 'true' And '$(CIEnabled)' == ''">false</CIEnabled>
    </PropertyGroup>

    <!-- Outer project will supply a default value - if absent we need this project to look itself -->
    <PropertyGroup Condition="'$(_PaketLockFile)' == ''">
      <_PaketLockFile>$([MSBuild]::GetPathOfFileAbove('paket.lock'))</_PaketLockFile>
    </PropertyGroup>

    <ItemGroup>
      <EmbeddedResource Condition="'$(_PaketLockFile)' != ''" Include="$(_PaketLockFile)">
        <LogicalName>paket.lock</LogicalName>
      </EmbeddedResource>
    </ItemGroup>

    <ItemGroup>
      <_AssemblyAttributes Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(IsIntegrationTest)' == 'true'">
        <_Parameter1>CIEnabled</_Parameter1>
        <_Parameter2>$(CIEnabled)</_Parameter2>
      </_AssemblyAttributes>

      <_AssemblyAttributes Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(IsIntegrationTest)' == 'true' And '$(CICategory)' != ''">
        <_Parameter1>CICategory</_Parameter1>
        <_Parameter2>$(CICategory)</_Parameter2>
      </_AssemblyAttributes>
    </ItemGroup>
  </Target>


  <Target Name="GatherCommonAssemblyAttributes">

    <PropertyGroup>
      <!-- Path.Combine to try handle trailing/non-trailing slashes -->
      <_GitDir Condition="'$(_GitDir)' == ''">$([System.IO.Path]::Combine($(SolutionDirectoryPath), '.git'))</_GitDir>

      <_HasGitDir Condition="'$(_HasGitDir)' == ''">false</_HasGitDir>
      <_HasGitDir Condition="Exists($(_GitDir))">true</_HasGitDir>
    </PropertyGroup>

    <GitVersion
      Condition="'$(_HasGitDir)' == 'true'"
      WorkingDirectory="$(_GitDir)">
      <Output PropertyName="GitCanonicalBranchName" TaskParameter="CanonicalBranchName" />
      <Output PropertyName="GitSha" TaskParameter="Sha" />
    </GitVersion>

    <ItemGroup>
      <_AssemblyAttributes Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(_HasGitDir)' == 'true'">
        <_Parameter1>Git.BranchName</_Parameter1>
        <_Parameter2>$(GitCanonicalBranchName)</_Parameter2>
      </_AssemblyAttributes>

      <_AssemblyAttributes Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(_HasGitDir)' == 'true'">
        <_Parameter1>Git.Sha</_Parameter1>
        <_Parameter2>$(GitSha)</_Parameter2>
      </_AssemblyAttributes>

      <_AssemblyAttributes Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(BUILD_BUILDID)' != ''">
        <_Parameter1>Build.Id</_Parameter1>
        <_Parameter2>$(BUILD_BUILDID)</_Parameter2>
      </_AssemblyAttributes>

      <_AssemblyAttributes Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(BUILD_SOURCEVERSION)' != ''">
        <_Parameter1>Build.SourceVersion</_Parameter1>
        <_Parameter2>$(BUILD_SOURCEVERSION)</_Parameter2>
      </_AssemblyAttributes>

      <_AssemblyAttributes Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(BUILD_REPOSITORY_URI)' != ''">
        <_Parameter1>Build.RepositoryUri</_Parameter1>
        <_Parameter2>$(BUILD_REPOSITORY_URI)</_Parameter2>
      </_AssemblyAttributes>

      <_AssemblyAttributes Include="System.Reflection.AssemblyMetadataAttribute" Condition="'$(BuildFlavor)' != ''">
        <_Parameter1>Build.Flavor</_Parameter1>
        <_Parameter2>$(BuildFlavor)</_Parameter2>
      </_AssemblyAttributes>
    </ItemGroup>

  </Target>


  <Target Name="FindRoleFiles" Condition="'$(IsIntegrationTest)' == 'true' Or '$(IsIntegrationTestHelper)' == 'true'">
    <RoleManifestPackageIdentifier
      ManifestSearchDirectories="@(ManifestSearchDirectories)"
      DependentRoles="@(DependentRoles)"
      PackageBlacklist="@(PackageBlacklist)" >
      <Output TaskParameter="DependentPackages" ItemName="DependentPackages" />
    </RoleManifestPackageIdentifier>

    <ItemGroup>
      <_AssemblyAttributes Include="@(DependentPackages)" />
    </ItemGroup>
  </Target>

  <PropertyGroup>
    <GenerateAssemblyInfoDependsOn>
      $(GenerateAssemblyInfoDependsOn);
      UpdateAssemblyInfoFile;
    </GenerateAssemblyInfoDependsOn>
  </PropertyGroup>


  <Target Name="UpdateCommonAssemblyInfo" DependsOnTargets="$(GenerateAssemblyInfoDependsOn)" />

  <!--
    Clone a copy of CommonAssemblyInfo.cs once, and then share that between all projects using the same original CommonAssemblyInfo.cs
  -->
  <Target Name="CloneCommonAssemblyInfoFile"
          BeforeTargets="UpdateAssemblyInfoFile"
          DependsOnTargets="$(CreateGeneratedAssemblyInfoInputsDependsOn)">

    <!-- Find CommonAssemblyInfo.cs in the "Compile" Items. Remove it from "Compile" Items because we will use a modified version instead. -->
    <ItemGroup>
      <CommonAssemblyInfoFile Include="@(Compile)" Condition="%(Filename) == 'CommonAssemblyInfo' And %(Extension) == '.cs'" />
      <!-- Now remove the original element -->
      <Compile Remove="@(CommonAssemblyInfoFile)" />
    </ItemGroup>

    <PropertyGroup>
      <CommonAssemblyInfoText Condition="@(CommonAssemblyInfoFile->Count()) != 0">$([System.IO.File]::ReadAllText('%(CommonAssemblyInfoFile.FullPath)'))</CommonAssemblyInfoText>
    </PropertyGroup>

    <Hash ItemsToHash="$(CommonAssemblyInfoText)">
      <Output TaskParameter="HashResult" PropertyName="_InputCommonAssemblyInfoFilePathHash" />
    </Hash>

    <Hash ItemsToHash="@(_AssemblyAttributes->'%(Identity)%(_Parameter2)')">
      <Output TaskParameter="HashResult" PropertyName="_CommonAssemblyAttributesPathHash" />
    </Hash>

    <PropertyGroup>
      <BasePath>$([System.IO.Path]::GetTempPath())MSBuild</BasePath>
    </PropertyGroup>

    <MakeDir Directories="$(BasePath)" />

    <CombinePath BasePath="$(BasePath)"
                 Paths="$(_CommonAssemblyAttributesPathHash)" >
      <Output TaskParameter="CombinedPaths" PropertyName="CommonAssemblyInfoAttributesFile" />
    </CombinePath>

    <PropertyGroup>
      <CommonAssemblyInfoAttributesFile>$(CommonAssemblyInfoAttributesFile).g.cs</CommonAssemblyInfoAttributesFile>
    </PropertyGroup>
  </Target>


  <!--  Emit the target attributes as a code
        fragment into a temporary source file for the compiler.-->

  <!-- The files generated or updated are shared between projects so we have to take care to handle simultaneous writes (by ContinueOnError) -->
  <Target Name="WriteCommonAssemblyInfoAttributesFile"
          AfterTargets="CloneCommonAssemblyInfoFile" Condition="'$(_CommonAssemblyAttributesPathHash)' != ''"
          Inputs="$(MSBuildProjectFullPath)"
          Outputs="$(CommonAssemblyInfoAttributesFile)">

    <WriteCodeFragment AssemblyAttributes="@(_AssemblyAttributes)"
                       Language="CS"
                       OutputFile="$(CommonAssemblyInfoAttributesFile)"
                       ContinueOnError="true" />

    <Touch Condition="'$(MSBuildLastTaskResult)' == 'true'"
           Files="$(CommonAssemblyInfoAttributesFile)"
           Time="$([System.IO.File]::GetCreationTime('$(MSBuildProjectFullPath)').ToString('o'))"
           ContinueOnError="true" />
  </Target>


  <Target Name="UpdateCopyright"
          AfterTargets="CloneCommonAssemblyInfoFile"
          Condition="'@(CommonAssemblyInfoFile->Count())' != '0'">

    <CombinePath BasePath="$(BasePath)"
                 Paths="$(_InputCommonAssemblyInfoFilePathHash)" >
      <Output TaskParameter="CombinedPaths" PropertyName="CommonAssemblyInfoCloneHash" />
    </CombinePath>

    <PropertyGroup>
      <CommonAssemblyInfoCloneFile>$(CommonAssemblyInfoCloneHash).cs</CommonAssemblyInfoCloneFile>
    </PropertyGroup>

  </Target>

  <Target Name="UpdateCopyrightCore"
          AfterTargets="UpdateCopyright"
          Inputs="$(MSBuildProjectFullPath)"
          Outputs="$(CommonAssemblyInfoCloneFile)">

    <PropertyGroup>
      <!-- Update copyright, $1, $2 and $4 are capture groups -->
      <ReplacementText>$1$2-$([System.DateTime]::Now.Year)$4</ReplacementText>
      <CommonAssemblyInfoText>$([System.Text.RegularExpressions.Regex]::Replace($(CommonAssemblyInfoText), "(.*?AssemblyCopyright)(.*?\d{4})(\s*-\s*\d{4})?(.*)", $(ReplacementText), System.Text.RegularExpressions.RegexOptions.IgnoreCase))</CommonAssemblyInfoText>
    </PropertyGroup>

    <WriteLinesToFile File="$(CommonAssemblyInfoCloneFile)"
                      Lines="$(CommonAssemblyInfoText)"
                      Overwrite="true"
                      ContinueOnError="true" />

    <Touch Condition="'$(MSBuildLastTaskResult)' == 'true'"
           Files="$(CommonAssemblyInfoCloneFile)"
           Time="$([System.IO.File]::GetCreationTime('$(MSBuildProjectFullPath)').ToString('o'))"
           ContinueOnError="true"  />

    <ItemGroup>
      <CommonAssemblyInfoCloneFiles Include="$(CommonAssemblyInfoCloneFile)"  />
    </ItemGroup>

  </Target>

  <!--
      Clones CommonAssemblyInfo.cs so we don't upset incremental builds
  -->
  <Target Name="UpdateAssemblyInfoFile">
    <!-- Include the cloned CommonAssemblyInfo.cs files in "Compile" items (instead of the original). -->
    <ItemGroup>
      <Compile Include="@(CommonAssemblyInfoCloneFiles)" />
      <Compile Include="$(CommonAssemblyInfoAttributesFile)" />
    </ItemGroup>
    <!-- Do not put in FileWrites:
         These are a files that are shared between projects in %temp%, and cleaning it would create a race between projects during rebuild -->
  </Target>

</Project>