<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003"
         ToolsVersion="14.0"
         TreatAsLocalProperty="UseCommonOutputDirectory">

  <Import Project="Aderant.Build.Common.targets" Condition="'$(PrepareBuildEnvironmentTargetImported)' == ''" />

  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>

    <WebContentProject Condition="'$(WebContentProject)' == ''">$(BuildScriptsDirectory)Aderant.wpp.Content.proj</WebContentProject>

    <!--This property is defined in Microsoft.Web.Publishing.targets-->
    <OnAfterPackageUsingManifest>$(OnAfterPackageUsingManifest);ReplicateOutputs</OnAfterPackageUsingManifest>

    <SignApplications Condition="'$(SignApplications)' == '' And Exists('$(MSBuildThisFileDirectory)\Aderant.CodeSigning.targets')">true</SignApplications>

    <!--No doc file, then suppress the no documentation warning-->
    <NoWarn Condition="'$(DocumentationFile)' == ''">$(NoWarn);1591;1570;1572;1573;1574</NoWarn>
    <WarningsNotAsErrors Condition="'$(DocumentationFile)' == ''">$(WarningsNotAsErrors);1591;1570;1572;1573;1574</WarningsNotAsErrors>
  </PropertyGroup>


  <Import Project="Aderant.CodeSigning.targets" Condition="'$(SignApplications)' == 'true'" />

  <!--
    Updates the product splash screen without touching the original file
  -->
  <Target Name="CommonBuildUpdateSplashscreen"
          Condition="'$(IsCustomBuild)' != 'true' And '$(OutputType)' == 'WinExe' And $(PackageId.EndsWith('.Api', StringComparison.OrdinalIgnoreCase)) != 'true'"
          AfterTargets="SetVersionAttributes">
    <!--
      This needs to run before BeforeResolveReferences target otherwise changes Resources item group
      is not reflected through out the in memory project
    -->

    <Error Text="Cannot find path to build tools" Condition="'$(BuildToolsDirectory)' == ''" />

    <!-- Find Expert_SplashScreen_ in the "Resource" Items. Remove it from "Resource" Items because we will use a modified version instead. -->
    <ItemGroup>
      <OriginalSplashScreen Include="@(Resource)" Condition="%(Extension) == '.png' And $([System.String]::Copy(%(Filename)).StartsWith('Expert_SplashScreen', StringComparison.OrdinalIgnoreCase))">
        <IsResource>true</IsResource>
      </OriginalSplashScreen>

      <OriginalSplashScreen Include="@(SplashScreen)" Condition="@(OriginalSplashScreen) == '' And %(Extension) == '.png' And $([System.String]::Copy(%(Filename)).StartsWith('Expert_SplashScreen', StringComparison.OrdinalIgnoreCase))">
        <IsSplashScreen>true</IsSplashScreen>
      </OriginalSplashScreen>

      <AssemblyInfo Include="@(Compile)" Condition="%(Filename) == 'AssemblyInfo' And %(Extension) == '.cs'" />

      <!-- Remove the original splash screen resource node -->
      <Resource Remove="@(OriginalSplashScreen)" />
      <SplashScreen Remove="@(OriginalSplashScreen)" />
    </ItemGroup>

    <GetProductName AssemblyInfo="@(AssemblyInfo)">
      <Output PropertyName="ExpertProductName"
              TaskParameter="ProductName" />
    </GetProductName>

    <PropertyGroup>
      <OutputSplashScreen>@(OriginalSplashScreen->'$(IntermediateOutputPath)%(RelativeDir)%(Filename)%(Extension)')</OutputSplashScreen>
    </PropertyGroup>

    <!--
      This task can return a previously generated file to keep incremental builds working.
    -->

    <PropertyGroup>
      <_VersionText Condition="'$(_VersionText)' == '' And '@(CommonAssemblyInformationalVersion)' != ''">%(CommonAssemblyInformationalVersion.Major).%(CommonAssemblyInformationalVersion.Minor)</_VersionText>
      <_VersionText Condition="'$(_VersionText)' == '' And '@(CommonAssemblyFileVersion)' != ''" >%(CommonAssemblyFileVersion.Major).%(CommonAssemblyFileVersion.Minor)</_VersionText>
      <_VersionText Condition="'$(_VersionText)' == '1.8' Or '$(_VersionText)' == ''">8.1</_VersionText>
      <SplashScreenVersion>Version $(_VersionText)</SplashScreenVersion>
      <SplashScreenText>$(ExpertProductName)</SplashScreenText>
    </PropertyGroup>

    <Error Condition="'$(_VersionText)' == ''" Text="The build was unable to find AssemblyInformationalVersion attribute or determine the current value of this attribute. Check that CommonAssemblyInfo.cs is linked to this project." />

    <Aderant.Build.Tasks.UpdateSplashScreenImage
     Condition="'@(OriginalSplashScreen)' != '' And '$(ExpertProductName)' != ''"

     TrackerLogDirectory="$(IntermediateOutputPath)"
     Sources="@(OriginalSplashScreen)"
     OutputFile="$(OutputSplashScreen)"
     TrackFileAccess="true"
     MinimalRebuildFromTracking="true"

     Text="$(SplashScreenText)"
     Version="$(SplashScreenVersion)"
     Style="$(SplashScreenStyle)">
    </Aderant.Build.Tasks.UpdateSplashScreenImage>

    <Message Text="Product Name: $(ExpertProductName)" Condition="' $(ExpertProductName)' != ''" />
    <Message Text="Splash screen style: $(SplashScreenStyle)" Condition="' $(SplashScreenStyle)' != ''" />
    <Message Text="Path to splash screen: $(OutputSplashScreen)" Condition="' $(OutputSplashScreen)' != ''" />

    <!-- Add the returned modified node from the update task into the in memory project -->
    <ItemGroup>
      <Resource Include="$(OutputSplashScreen)" Condition="'%(OriginalSplashScreen.IsResource)' == 'true'" />
      <SplashScreen Include="$(OutputSplashScreen)" Condition="'%(OriginalSplashScreen.IsSplashScreen)' == 'true'" />
    </ItemGroup>
  </Target>


  <PropertyGroup>
    <GetReferenceAssemblyPathsDependsOn>
      $(GetReferenceAssemblyPathsDependsOn);
      SetAssemblySearchPaths
    </GetReferenceAssemblyPathsDependsOn>
  </PropertyGroup>

  <!-- Code to handle project references in Customization build. Aderant.Build.dll is packed into BuildScripts.zip in Framework build. -->
  <UsingTask TaskName="SmartReference" Condition="'$(IsCustomBuild)' == 'true'"
             AssemblyFile="$(BuildScriptsDirectory)\Build.Tools\Aderant.Build.dll" />


  <Target Name="CollectNugetPackagePaths"
	        Condition="'$(IsCustomBuild)' != 'true'">
    <Error Condition="'$(RootFolder)' == ''" Text="RootFolder is undefined" />

    <PropertyGroup>
      <NugetPackageCacheKey>NugetPackagePaths</NugetPackageCacheKey>
    </PropertyGroup>

    <!-- Perf optimization: Cache the paths so we don't constantly go back to disk to re-discover the same information -->
    <StringCache Key="$(NugetPackageCacheKey)">
      <Output TaskParameter="Value" PropertyName="_PackageDirectoriesAsSingleItem" />
      <Output TaskParameter="HasValueForKey" PropertyName="_PackageDirectoriesHasValue" />
    </StringCache>

    <ItemGroup Condition="'$(_PackageDirectoriesHasValue)' != 'true'">
      <_AllFiles Include="$(RootFolder)\packages\**\lib\**\*.dll"
                 Exclude="$(RootFolder)\packages\**\lib\**\Newtonsoft*.dll" />

      <NugetPackageFoldersToIgnore Include="MonoAndroid10;MonoTouch10;win8;wp8;wpa81;uap;Xamarin;monoandroid90;xamarinios10;xamarinmac20" />
      <NugetPackageFoldersToIgnore Include="de-DE;es-ES;fr-FR;it-IT;ja-JP;ko-KR;pt-BR;ru-RU;zh-CN;zh-TW;zh-Hans;zh-Hant" />
      <NugetPackageFoldersToIgnore Include="cs;de;es;fr;it;ja;ko;pl;ru;tr;sl4" />

      <!-- Never automatically include net20 as its simply too old - if you want this add a hint path -->
      <NugetPackageFoldersToIgnore Include="net20" />

      <!-- Trim the path separator off so %(Filename) resolves -->
      <_PackageDirectories Include="@(_AllFiles->'%(RootDir)%(Directory)'->TrimEnd('\')->Distinct())" />

      <_PackageDirectories Remove="@(_PackageDirectories)" Condition="'%(Filename)' == '@(NugetPackageFoldersToIgnore->'%(Filename)')'" />
    </ItemGroup>

    <StringCache Condition="'$(_PackageDirectoriesHasValue)' != 'true'"
                 Key="$(NugetPackageCacheKey)"
                 Value="@(_PackageDirectories)">
      <!--Always output the value to avoid cache miss the first time-->
      <Output TaskParameter="Value" PropertyName="_PackageDirectoriesAsSingleItem" />
    </StringCache>

  </Target>


  <Target Name="AssignPropertiesForCustomSearchPaths">
    <PropertyGroup>
      <!-- Walk up and find the solution root -->
      <RootFolder>$(SolutionPath)</RootFolder>
      <RootFolder Condition="'$(RootFolder)' == ''">$(SolutionRoot)</RootFolder>
      <RootFolder Condition="'$(RootFolder)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove('$(MSBuildProjectDirectory)', 'dir.proj'))</RootFolder>
      <RootFolder Condition="'$(RootFolder)' == ''">$([MSBuild]::GetDirectoryNameOfFileAbove('$(MSBuildProjectDirectory)', 'paket.dependencies'))</RootFolder>

      <CopyLocalDependenciesWhenParentReferenceInGac>false</CopyLocalDependenciesWhenParentReferenceInGac>
      <DoNotCopyLocalIfInGac>true</DoNotCopyLocalIfInGac>

      <ResolveAssemblyReferencesSilent>false</ResolveAssemblyReferencesSilent>

      <!-- This defaults to true within RAR and causes RAR to go off and find dependencies of dependencies which I feel is unnecessary. -->
      <!-- <_FindDependencies>false</_FindDependencies>  -->
    </PropertyGroup>
  </Target>


  <PropertyGroup>
    <!--PERF: Avoid looking for winmd files.
          Put the most likely extensions first for reference resolution speed.
      -->
    <AllowedReferenceAssemblyFileExtensions>
      .dll;
      .exe
    </AllowedReferenceAssemblyFileExtensions>
    <!--
        These are the extensions that reference resolution will consider when looking for files related
        to resolved references. Here we ignore pdb and xml for test projects to avoid pulling in that baggage.
        A dummy name is provided to fool the ResolveAssemblyReference task.
      -->
    <AllowedReferenceRelatedFileExtensions Condition=" $(ProjectTypeGuids.Contains('3AC096D0-A1C2-E12C-1390-A8335801FDAB')) == 'true' ">
      _
    </AllowedReferenceRelatedFileExtensions>
  </PropertyGroup>


  <Target Name="SetAssemblySearchPaths"
          DependsOnTargets="AssignPropertiesForCustomSearchPaths;CollectNugetPackagePaths">

    <!--
        This changes the search path of the ResolveReferences task to look in the dependencies/packages folder. The normal probe sequence is

        (1) Files from current project - indicated by {CandidateAssemblyFiles}
        (2) $(ReferencePath) - the reference path property, which comes from the .USER file.
        (3) The hintpath from the referenced item itself, indicated by {HintPathFromItem}.
        (4) The directory of MSBuild's "target" runtime from GetFrameworkPath.
            The "target" runtime folder is the folder of the runtime that MSBuild is a part of.
        (5) Registered assembly folders, indicated by {Registry:*,*,*}
        (6) Legacy registered assembly folders, indicated by {AssemblyFolders}
        (7) Resolve to the GAC.
        (8) Treat the reference's Include as if it were a real file name.
        (9) Look in the application's output folder (like bin\debug)
    -->

    <ItemGroup Condition="'$(UsePackagesDirectorySearchPath)' != 'false'">
      <AssemblySearchDirectories Include="$([MSBuild]::Unescape($(_PackageDirectoriesAsSingleItem)))" />
    </ItemGroup>

    <PropertyGroup>
      <ProgramFiles32>$(MSBuildProgramFiles32)</ProgramFiles32>
      <_VSSDKSuffix>VSSDK\VisualStudioIntegration\Common\Assemblies\v4.0</_VSSDKSuffix>
      <_PublicAssembliesSuffix>Common7\IDE\PublicAssemblies</_PublicAssembliesSuffix>
      <_VS2017InstallDirectory>$(ProgramFiles32)\Microsoft Visual Studio\2017\</_VS2017InstallDirectory>
      <_WIXLib>$(ProgramFiles32)\WiX Toolset v3.11\bin</_WIXLib>
      <_Pia2010>$(ProgramFiles32)\Microsoft Visual Studio 14.0\Visual Studio Tools for Office\PIA\Office14\</_Pia2010>
    </PropertyGroup>

    <ItemGroup>
      <AssemblySearchDirectories Condition="'$(ReferencePath)' != ''" Include="$(ReferencePath)" />
      <!--Adding additional dependencies searching locations. -->
      <AssemblySearchDirectories Condition="'$(ExpertSourceDirectory)' != ''" Include="$(ExpertSourceDirectory)" />
      <AssemblySearchDirectories Condition="'$(ExpertSourceDirectory)' != ''" Include="$(ExpertSourceDirectory)StoredProcedures" />
    </ItemGroup>

    <PropertyGroup>
      <!-- Create the assembly search paths property. This defines where\how references are resolved.
           This path order places our search paths first.
           ReferencePath may not have been set when AssemblySearchPaths was defined. So we set it in the candidate list again just in case. -->
      <AssemblySearchPaths>
        $(AlternativeOutputDirectory);
        $(AlternativeOutputDirectory)StoredProcedures;
        $(AssemblySearchPaths);
        $(RootFolder)\Dependencies\;
        @(AssemblySearchDirectories);
        $(_WIXLib);
        $(_Pia2010);
        $(_VS2017InstallDirectory)Enterprise\$(_VSSDKSuffix);
        $(_VS2017InstallDirectory)Enterprise\$(_PublicAssembliesSuffix);
        $(_VS2017InstallDirectory)Professional\$(_VSSDKSuffix);
        $(_VS2017InstallDirectory)Professional\$(_PublicAssembliesSuffix)
      </AssemblySearchPaths>

      <!--Prevent hunting into legacy registry assembly folders https://stackoverflow.com/questions/50638711/msbuild-is-replacing-newtonsoft-json-dll-with-an-older-version -->
      <AssemblySearchPaths>$(AssemblySearchPaths.Replace('{AssemblyFolders}', '').Split(';'))</AssemblySearchPaths>
    </PropertyGroup>

    <!-- Check if any project references need to be fixed. -->
    <SmartReference
      Condition="'$(IsCustomBuild)' == 'true' And '$(ExpertSourceDirectory)' != ''"
      ProjectReferences="@(ProjectReference)"
      References="@(Reference)"
      AlternativeOutputDirectory="$(AlternativeOutputDirectory)"
      ExpertSourceDirectory="$(ExpertSourceDirectory)"
      Customization="true">
      <Output TaskParameter="ModifiedProjectReferences" ItemName="ModifiedProjectReferences" />
      <Output TaskParameter="ModifiedReferences" ItemName="ModifiedReferences" />
    </SmartReference>

    <!-- If any changes happen, update the ModifiedProjectReferences. -->
    <ItemGroup Condition="'@(ModifiedProjectReferences)' != ''">
      <ProjectReference Remove="@(ProjectReference)" />
      <ProjectReference Include="@(ModifiedProjectReferences)" />
    </ItemGroup>

    <ItemGroup>
      <Reference Include="@(ModifiedReferences)" />
    </ItemGroup>

  </Target>


  <Target Name="CheckOrmMappingFile" BeforeTargets="CoreBuild"
          Condition="'$(IsCustomBuild)' != 'true' And '$(AssemblyName)' != 'Aderant.Framework.SoftwareFactory.Domain'">

    <Aderant.Build.Tasks.OrmMappingValidator
      Condition="'$(DisableOrmMappingValidator)' != 'true'"
      Content="@(Content)"
      Compile="@(Compile)"
      None="@(None)"
      EmbeddedResource="@(EmbeddedResource)"
      ProjectTypeGuids="$(ProjectTypeGuids)" />

  </Target>


  <!-- Disable copy local for all projects which build to Bin\Module excluding Office integration projects (addins).
       VSTO projects run a target called VisualStudioForApplicationsBuild which executes FindRibbons. The FindRibbons task is stupid and has no
       mechanism for supply a dependency directory - it depends on the dependencies of your project being available by virtue of copy local -->
  <Target Name="CommonBuildDisableCopyLocal"
          BeforeTargets="BeforeResolveReferences"
          AfterTargets="SetAssemblySearchPaths"
          Condition="('$(VSTO_ProjectType)' == '' And '$(WixCATargetsPath)' == '') And '$(DisableCopyLocal)' != 'false'">

    <!-- Contains is used to cover Bin\Module and Bin\Module\ -->
    <PropertyGroup>
      <DisableCopyLocal Condition="$(OutputPath.ToLower().Contains('bin\module')) == 'true'">true</DisableCopyLocal>
      <DisableCopyLocal Condition="'$(IsWebModule)' != 'true' And $(OutputPath.ToLower().Contains('bin\test')) == 'true'">false</DisableCopyLocal>

      <DisableCopyLocal Condition="'%(Whitelist.Identity)' == '$(AssemblyName)'">false</DisableCopyLocal>

      <!-- This changes the copy local behaviour for _CopyFilesMarkedCopyLocal -->
      <UseCommonOutputDirectory Condition="'$(DisableCopyLocal)' == 'true'">true</UseCommonOutputDirectory>
    </PropertyGroup>

    <Message Text="Copy local disabled: $(DisableCopyLocal)" Importance="Low" />

    <ItemGroup>
      <ReferenceNew Include="@(Reference)" Condition="'$(DisableCopyLocal)' == 'true'">
        <Private>False</Private>
        <CopyLocal>False</CopyLocal>
      </ReferenceNew>

      <Reference Remove="@(Reference)" Condition="'$(DisableCopyLocal)' == 'true'" />

      <!-- Replace the Reference item group with the modified version -->
      <Reference Include="@(ReferenceNew)" Condition="'$(DisableCopyLocal)' == 'true'" />
    </ItemGroup>
  </Target>


  <Target Name="SetUseCommonOutputDirectoryForVsto"
          BeforeTargets="BeforeResolveReferences"
          Condition="'$(VSTO_ProjectType)' != ''">

    <PropertyGroup>
      <UseCommonOutputDirectory>false</UseCommonOutputDirectory>
    </PropertyGroup>
  </Target>


  <Target Name="AddAssemblyInfo"
          BeforeTargets="CoreCompile"
          DependsOnTargets="PrepareForBuild;"
          Condition="'$(GeneratedAssemblyInfoFile)' != '' And $(GenerateAssemblyInfo) != false">

    <ItemGroup>
      <Compile Include="$(GeneratedAssemblyInfoFile)" />
    </ItemGroup>

  </Target>


  <!--
    This target only runs after the publishing step of a VSTO addin project
    It is used to clean up the reference items that are moved into the bin folder during the build.
    We cannot suppress the copy local items as they could be dependencies needed for the FindRibbons task to run successfully.
    In summary for VSTO projects we will copy local the dependencies, run the VSTO pipeline and then clean up the bin folder afterwards.
  -->
  <Target Name="AfterVstoPublish"
          AfterTargets="AfterPublish"
          Condition="'$(VSTO_ProjectType)' != ''">

    <ItemGroup>
      <Dependencies Include="..\..\Dependencies\*.dll" />
    </ItemGroup>

    <!--FileWritesShareable comes from the Microsoft CopyLocal target -->
    <GetCopyLocalItemsToRemove
       SourceFiles="@(FileWritesShareable)"
       Dependencies="@(Dependencies)">
      <Output TaskParameter="CopyLocalFiles" ItemName="CopyLocalFilesToRemove" />
    </GetCopyLocalItemsToRemove>

    <Delete Files="@(CopyLocalFilesToRemove)" />

    <!-- Remove empty directories -->
    <ItemGroup>
      <Directories Include="$([System.IO.Directory]::GetDirectories($(OutDir), '*', System.IO.SearchOption.AllDirectories))" />
      <Directories>
        <Files>$([System.IO.Directory]::GetFiles("%(Directories.Identity)", "*", System.IO.SearchOption.AllDirectories).get_Length())</Files>
      </Directories>
    </ItemGroup>

    <RemoveDir Directories="@(Directories)" Condition="'%(Files)' == '0'" />

  </Target>

  <Target Name="ReplicateOutputs" AfterTargets="AfterBuild" Condition="'$(AlternativeOutputDirectory)' != '' And '$(DisableReplicateOutputs)' != 'True'">

    <Delete Files="@(IntermediateAssembly->'$(AlternativeOutputDirectory)%(Filename)%(Extension)')"
            ContinueOnError="true" />

    <ItemGroup>
      <DestinationFolders Include="$(AlternativeOutputDirectory)" />
    </ItemGroup>

    <Message Text="Assemblies to copy: @(IntermediateAssembly->'$(OutputPath)%(Filename)%(Extension)')"></Message>

    <Copy
      SourceFiles="@(IntermediateAssembly->'$(OutputPath)%(Filename)%(Extension)')"
      Condition="Exists('@(IntermediateAssembly->'$(OutputPath)%(Filename)%(Extension)')')"
      DestinationFolder="%(DestinationFolders.FullPath)"
      UseHardlinksIfPossible="true"
      OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
      Retries="$(CopyRetryCount)"
      RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
      ContinueOnError="true">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
    </Copy>

    <PropertyGroup>
      <IsTestProject>$([System.IO.Path]::GetFileName('$(MSBuildProjectFullPath)').Contains('Test'))</IsTestProject>
			<IsDatabaseProject>$(MSBuildProjectName.StartsWith('Database'))</IsDatabaseProject>
    </PropertyGroup>

    <!-- Send all outputs of the project to the update staging area for later collection. -->
    <Message Condition="'$(IncludeOutputInUpdatePackage)' == 'true' And '$(IsTestProject)' == 'False'" Importance="High" Text="Including outputs from $(MSBuildProjectFullPath) in update package" />
    <Message Condition="'$(IsTestProject)' == 'True'" Text="Excluding outputs from: '$(MSBuildProjectFullPath)' in update package as it is considered a test project." />
    <MSBuild Condition="'$(IncludeOutputInUpdatePackage)' == 'true' And '$(IsTestProject)' == 'False' And '$(IsDatabaseProject)' == 'False' "
             Projects="$(MSBuildProjectFullPath)"
             Targets="CopyFilesToOutputDirectory"
             Properties="OutDir=$(UpdateStagingDirectory)\BinFiles;
                         CreateHardLinksForCopyAdditionalFilesIfPossible=true;
                         CopyOutputSymbolsToOutputDirectory=false;
                         _DocumentationFileProduced=false" />

    <Message Condition="'$(IncludeOutputInUpdatePackage)' == 'true' And '$(PackageFileName)' != ''" Text="Package File Name: '$(PackageFileName)'." />
    <Message Condition="'$(IncludeOutputInUpdatePackage)' == 'true'" Text="Update Staging Directory: '$(UpdateStagingDirectory)'." />

    <Copy
      Condition="'$(IncludeOutputInUpdatePackage)' == 'true' And '$(IsTestProject)' == 'False' And '$(PackageFileName)' != '' And Exists('$(PackageFileName)')"
      SourceFiles="$(PackageFileName)"
      DestinationFolder="$(UpdateStagingDirectory)"
      OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
      Retries="$(CopyRetryCount)"
      RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"/>

    <PropertyGroup>
      <RelativeArtifactStagingDirectory>$([MSBuild]::MakeRelative($(MSBuildProjectDirectory), $(AlternativeOutputDirectory)))</RelativeArtifactStagingDirectory>
      <RelativeArtifactStagingDirectory Condition="!Exists('$(RelativeArtifactStagingDirectory)')"></RelativeArtifactStagingDirectory>

      <!--Ignore file writes from web projects -->
      <RelativePackagesDirectory>$([MSBuild]::MakeRelative($(MSBuildProjectDirectory), '..\..\packages'))</RelativePackagesDirectory>
      <RelativePackagesDirectory Condition="!Exists('$(RelativePackagesDirectory)')"></RelativePackagesDirectory>
    </PropertyGroup>

    <RecordProjectOutputs
	    Condition="'$(IsCustomBuild)' != 'true'"
      ContextEndpoint="$(ContextEndpoint)"
      SolutionRoot="$(SolutionRoot)"
      ProjectTypeGuids="$(ProjectTypeGuids)"
      TestProjectType="$(TestProjectType)"
      References="@(Reference)"
      ProjectFile="$(MSBuildProjectFullPath)"
      IntermediateDirectories="$(IntermediateOutputPath);$(RelativeArtifactStagingDirectory);$(RelativePackagesDirectory)"
      OutputPath="$(OutDir)"
      FileWrites="@(FileWrites);$(PackageFileName)" />

  </Target>

  <PropertyGroup Condition="'$(IsDesktopBuild)' == 'false' And '$(CreateHardLinksForCopyLocal)' != ''">
    <CreateHardLinksForCopyLocalIfPossible>$(CreateHardLinksForCopyLocal)</CreateHardLinksForCopyLocalIfPossible>
  </PropertyGroup>

  <Import Project="Aderant.CSharp.overrides.targets" Condition="'$(CreateHardLinksForCopyLocalIfPossible)' == 'true'" />

</Project>