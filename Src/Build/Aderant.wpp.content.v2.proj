<?xml version="1.0" encoding="utf-8"?>
<!--WebDependencyVersion 3-->
<Project
  xmlns="http://schemas.microsoft.com/developer/msbuild/2003"
  ToolsVersion="14.0">

  <PropertyGroup>
    <DependenciesDirectory Condition="'$(DependenciesDirectory)' == ''">$(MSBuildThisFileDirectory)</DependenciesDirectory>
    <DependenciesDirectory>$([System.IO.Path]::GetFullPath('$(DependenciesDirectory)'))</DependenciesDirectory>
    <DependenciesDirectory Condition="!HasTrailingSlash('$(DependenciesDirectory)')">$(DependenciesDirectory)\</DependenciesDirectory>
    <PackagesDirectory>$([System.IO.Path]::GetFullPath('$(DependenciesDirectory)..\packages\'))</PackagesDirectory>
    <ModulesDirectory Condition="'$(ModulesDirectory)' == ''">$([System.IO.Path]::GetFullPath('$(DependenciesDirectory)..\..\'))</ModulesDirectory>
    <!-- only works for TFS modules right now -->
    <ResponseFile>$(SolutionDir)\Build\TFSBuild.rsp</ResponseFile>

  </PropertyGroup>

  <!-- 
    We need to share JavaScript, CSS or images files amongst several web applications.
    
    This target takes care of including the shared content from the dependency directory into the project and importantly maintaining 
    the F5 experience by virtue of the CopyLinkedContentFiles target  
  -->

  <!--ExternalContent item group defines the unprocessed content provided by dependency modules or by the file system in the module dependency directory

    Wildcards don't get expanded when you use the MS Build item selector (@->) so we stuck with a hardcoded list of folders to process.
    Ideally this syntax would work @(Modules->'$(DependenciesDirectory)Web.*\%(Identity\*.js') ... but it doesn't expand the * item unless it passes
    through a target which we cannot do here as this file is included by Visual Studio and cannot call into a target
  -->
  <PropertyGroup>
    <UnitTestProjectGuid>3AC096D0-A1C2-E12C-1390-A8335801FDAB</UnitTestProjectGuid>
    <EnableContentLink Condition="'$(EnableContentLink)' == ''">true</EnableContentLink>
    <EnableContentLink Condition="'$(ProjectTypeGuids.ToUpper().Contains($(UnitTestProjectGuid)))' == 'true'">false</EnableContentLink>

    <DependencyManifest>$(ProjectDir)..\..\Build\DependencyManifest.xml</DependencyManifest>
    <DependencyManifestContent>$([System.IO.File]::ReadAllText('$(DependencyManifest)'))</DependencyManifestContent>
    <Pattern>="((Aderant.Web|Web|Mobile)\..*?)"</Pattern>
    <!-- 
      Extract the web modules referenced in the dependency manifest
      The extracted result looks like ="Web.Foundation"
    -->
    <WebModuleText>$([System.Text.RegularExpressions.Regex]::Matches($(DependencyManifestContent), $(Pattern)))</WebModuleText>
    <WebModuleText>$(WebModuleText.Replace('=', '').Replace('"', ''))</WebModuleText>

    <RegexEscapedDependencyPath>$([System.Text.RegularExpressions.Regex]::Escape('$(DependenciesDirectory)'))</RegexEscapedDependencyPath>
  </PropertyGroup>


  <ItemGroup>
    <!--
      Creates the list of modules from the dependency manifest like Web.Foundation, Web.Presentation etc
      Extend this collection to extend the content inclusion pipeline from the depenedencies folder
  -->
    <ReferencedWebModules Include="$(WebModuleText.Split(';'))" />
  </ItemGroup>

  <!--
  ******************************************************************************** Content from dependencies ********************************************************************************
  -->
  <!-- Scripts -->
  <ItemGroup Condition=" '$(EnableContentLink)' == 'true' ">
    <ExternalContent Include="$(DependenciesDirectory)Web.*\Scripts\Web.*\**\*.js;
                              $(DependenciesDirectory)Web.*\Scripts\Web.*\**\*.html;
                              $(DependenciesDirectory)Web.*\Scripts\*.js;
                              $(DependenciesDirectory)Mobile.*\Scripts\*.js;
                              $(DependenciesDirectory)Mobile.*\Scripts\Mobile.*\**\*.js"
                     Exclude="$(DependenciesDirectory)Web.*\Scripts\ThirdParty.*\**\*.js">
      <RelativePath>Scripts</RelativePath>
      <Type>Content</Type>
    </ExternalContent>


    <ThirdPartyContent Include="$(DependenciesDirectory)ThirdParty.*\**\*.js">
      <RelativePath>Scripts\%(RecursiveDir)</RelativePath>
      <Type>Content</Type>
    </ThirdPartyContent>

    <ThirdPartyContent Include="$(PackagesDirectory)javascript\ThirdParty.*\lib\**\*.js">
      <RelativePath>Scripts\$([System.String]::Copy('%(RecursiveDir)').Replace('\lib', ''))</RelativePath>
      <Type>Content</Type>
    </ThirdPartyContent>

  </ItemGroup>

  <!-- Content (Less/Images) -->
  <ItemGroup Condition=" '$(EnableContentLink)' == 'true' ">

    <ExternalContent Include="$(DependenciesDirectory)Web.*\Content\**\*;
                              $(DependenciesDirectory)Mobile.*\Content\**\*"
                     Exclude="$(DependenciesDirectory)Web.*\Content\Web.*\**\*.js;
                              $(DependenciesDirectory)Web.*\Content\Web.*\**\*.d.ts;
                              $(DependenciesDirectory)Web.*\Content\Web.*\Web.*\**;
                              $(DependenciesDirectory)Web.*\Content\ThirdParty.*\**\*;
                              $(DependenciesDirectory)Mobile.*\Content\**\*.js;
                              $(DependenciesDirectory)Mobile.*\Content\**\*.d.ts;
                              $(DependenciesDirectory)Mobile.*\Content\Web.*\**;
                              $(DependenciesDirectory)Mobile.*\Content\Mobile.*\**">
      <RelativePath>Content</RelativePath>
      <Type>Content</Type>
    </ExternalContent>

    <ThirdPartyContent Include="$(DependenciesDirectory)ThirdParty.*\**\*"
                       Exclude="$(DependenciesDirectory)ThirdParty.*\**\*.js;
                                $(DependenciesDirectory)ThirdParty.*\**\*.d.ts">
      <RelativePath>Content\Includes\%(RecursiveDir)</RelativePath>
      <Type>Content</Type>
    </ThirdPartyContent>

    <ThirdPartyContent Include="$(PackagesDirectory)javascript\ThirdParty.*\lib\**\*"
                       Exclude="$(PackagesDirectory)javascript\ThirdParty.*\lib\**\*.js;
                                $(PackagesDirectory)javascript\ThirdParty.*\lib\**\*.d.ts">
      <RelativePath>Content\Includes\$([System.String]::Copy('%(RecursiveDir)').Replace('\lib', ''))</RelativePath>
      <Type>Content</Type>
    </ThirdPartyContent>

  </ItemGroup>

  <!-- ViewModels -->
  <ItemGroup Condition=" '$(EnableContentLink)' == 'true' ">
    <ExternalContent Include="$(DependenciesDirectory)Web.*\ViewModels\**\*.js;
                              $(DependenciesDirectory)Mobile.*\ViewModels\**\*.js"
                     Exclude="$(DependenciesDirectory)Mobile.*\ViewModels\Web.*\**;
                              $(DependenciesDirectory)Mobile.*\ViewModels\Mobile.*\**">
      <RelativePath>ViewModels</RelativePath>
      <Type>Content</Type>
    </ExternalContent>

    <ExternalContent Condition="'$(IsGitRepo)' != 'True'" Include="$(DependenciesDirectory)Web.*\ViewModels\**\*.d.ts"
                     Exclude="$(DependenciesDirectory)Web.*\ViewModels\Web.SMB\**\*.d.ts">
      <Type>TypeScript</Type>
    </ExternalContent>

  </ItemGroup>
  
  <!-- Views -->
  <ItemGroup Condition=" '$(EnableContentLink)' == 'true' ">
    <ExternalContent Include="$(DependenciesDirectory)Web.*\Views\**\Shared\**\*.cshtml">
      <RelativePath>Views/Shared</RelativePath>
      <Type>Content</Type>
    </ExternalContent>
  </ItemGroup>

  <!-- 
    Content Processing 
    
    Assign relative project path
    Exclude content not referenced by the dependency manifest
  -->
  <ItemGroup Condition=" '$(EnableContentLink)' == 'true' ">
    <AllDependencyContent Include="@(ExternalContent)">
      <!-- 
        DependenciesRelativePath returns a path with the path up to the module in the dependency folder removed        
      -->
      <DependenciesRelativePath>$([System.String]::Copy(%(FullPath)).Replace($(DependenciesDirectory), ''))</DependenciesRelativePath>

      <DependencyModule>$([System.Text.RegularExpressions.Regex]::Match('%(DependenciesRelativePath)', '((Web|Mobile)\.\w*?\\)'))</DependencyModule>
      <Module>$([System.String]::Copy(%(DependencyModule)).TrimEnd('\\'))</Module>
      <GitModule>$([System.String]::Copy(Aderant.%(DependencyModule)).TrimEnd('\\'))</GitModule>

      <RegexEscapedIdentity>$([System.Text.RegularExpressions.Regex]::Escape('%(Module)'))</RegexEscapedIdentity>
      <RegexEscapedPresentation>$([System.Text.RegularExpressions.Regex]::Escape('Web.Presentation'))</RegexEscapedPresentation>
      <RegexEscapedFoundation>$([System.Text.RegularExpressions.Regex]::Escape('Web.Foundation'))</RegexEscapedFoundation>
      <RegexEscapedOTG>$([System.Text.RegularExpressions.Regex]::Escape('Web.OTG'))</RegexEscapedOTG>
      <RegexContentPattern>%(RegexEscapedIdentity)(.*)(%(RegexEscapedIdentity))</RegexContentPattern>
      <RegexContentPattern Condition="'%(Module)' == 'Web.Core'">%(RegexEscapedIdentity)(.*)(%(RegexEscapedIdentity)|%(RegexEscapedPresentation)|%(RegexEscapedFoundation)|%(RegexEscapedOTG))</RegexContentPattern>
      

      <!-- Test if this is direct or transitive content like Modules\Web.SMB\Dependencies\Web.Presentation\Scripts\Web.Foundation\add2home.js -->
      <ContentIsNonTransitive>$([System.Text.RegularExpressions.Regex]::IsMatch('%(DependenciesRelativePath)', '%(RegexContentPattern)'))</ContentIsNonTransitive>


      <RegexNestedWebPattern>%(RegexEscapedIdentity)(.*)(Web|Mobile|Thirdparty|ThirdParty)\.\w*?\\</RegexNestedWebPattern>
      <!-- Test if this is nested content like Modules\Web.SMB\Dependencies\Web.Presentation\Scripts\Web.Foundation\add2home.js -->
      <ContentIsNestedWeb>$([System.Text.RegularExpressions.Regex]::IsMatch('%(DependenciesRelativePath)', '%(RegexNestedWebPattern)'))</ContentIsNestedWeb>

      <!-- Test if the content is from any known modules from the dependency manifest -->
      <IsReferenced>$(WebModuleText.Contains(%(Module)))</IsReferenced>
      
      <!--Can be removed once Mobile.* modules are in git-->
      <IsReferenced Condition="'%(IsReferenced)' == 'false'">$(MSBuildProjectName.Contains('Mobile.'))</IsReferenced>
      <!--Can be removed once Mobile.* modules are in git-->
      <IsReferenced Condition="'%(IsReferenced)' == 'false'">$(WebModuleText.Contains(%(GitModule)))</IsReferenced>
    </AllDependencyContent>

    <AllDirectContent Include="@(AllDependencyContent->WithMetadataValue('ContentIsNonTransitive', 'True'))" />

    <AllDirectNotNestedContent Include="@(AllDependencyContent->WithMetadataValue('ContentIsNestedWeb', 'False'))" />

    <!-- 
      During the build all there might be more Web modules in the dependency folder than those referenced by directly by this module.
      This transform takes care of ensuring only paths that contain referenced module content are included in the project and thus zipped package
    -->
    <DependencyContent Include="@(AllDirectContent->WithMetadataValue('IsReferenced', 'True'))">
      <!--         
        ProjectRelativePath returns a path that represents the relative include path within the project eg Scripts\Web.Foundation\foo.js
      -->
      <ProjectRelativePath>$([System.Text.RegularExpressions.Regex]::Replace(%(DependenciesRelativePath), '^(.*?\\.*?)', ''))</ProjectRelativePath>

    </DependencyContent>



    <DependencyContent Include="@(AllDirectNotNestedContent->WithMetadataValue('IsReferenced', 'True'))">
      <!--         
        ProjectRelativePath returns a path that represents the relative include path within the project eg Scripts\Web.Foundation\foo.js
      -->
      <Path>$([System.Text.RegularExpressions.Regex]::Replace(%(DependenciesRelativePath), '^(.*?\\.*?)', ''))</Path>
      <ProjectRelativePath Condition="%(RelativePath) != ''">%(RelativePath)\%(Module)\%(Filename)%(Extension)</ProjectRelativePath>
    </DependencyContent>

    <Content  Include="@(DependencyContent->WithMetadataValue('Type', 'Content'))">
      <Link Condition="%(ProjectRelativePath) != ''">%(ProjectRelativePath)</Link>
      <Visible Condition="%(ProjectRelativePath) != ''">true</Visible>
    </Content>

    <!-- And now for our third party library friends! Enter! Stage left! -->
    <Content Include="@(ThirdPartyContent->WithMetadataValue('Type', 'Content'))">
      <Link>%(RelativePath)%(Filename)%(Extension)</Link>
      <Visible>true</Visible>
    </Content>

    <TypeScriptCompile Include="@(ThirdPartyContent->WithMetadataValue('Type', 'TypeScript'))">
      <Link>%(RelativePath)%(Filename)%(Extension)</Link>
      <Visible>true</Visible>
    </TypeScriptCompile>
  </ItemGroup>



  
    
  <Target Name="CollectLinkedContentFiles" BeforeTargets="CopyLinkedContentFiles">

    <ItemGroup>
      <ContentToCopy Include="@(Content->HasMetadata('Link'))">
        <OriginalItemSpec>%(FullPath)</OriginalItemSpec>
      </ContentToCopy>

      <ContentToCopy Include="@(TypeScriptCompile->HasMetadata('Link'))">
        <OriginalItemSpec>%(FullPath)</OriginalItemSpec>
      </ContentToCopy>
    </ItemGroup>

  </Target>


  <!-- Maintains the
  F5 experience -->
  <Target Name="CopyLinkedContentFiles"
          DependsOnTargets="CollectLinkedContentFiles"
          Condition="'$(LinkedBuild)' != 'true' And '$(EnableContentLink)' == 'true'"
          BeforeTargets="PreComputeCompileTypeScript;Build;CopyAllFilesToSingleFolderForMsdeploy;PreAutoParameterizationWebConfigConnectionStrings"
          Inputs="@(ContentToCopy)"
          Outputs="@(ContentToCopy->'$(ProjectDir)%(Link)')">

    <!-- Only copy files with the Link attribute set -->
    <Copy SourceFiles="%(ContentToCopy.OriginalItemSpec)"
          DestinationFiles="@(ContentToCopy->'$(ProjectDir)%(Link)')"
          SkipUnchangedFiles="true"
          OverwriteReadOnlyFiles="true"
          UseHardlinksIfPossible="true" />

  </Target>
  
  <Target Name="CompileLess"
          AfterTargets="CopyLinkedContentFiles"
          Condition="'$(EnableLESSCompile)' == 'True'">
    <ItemGroup>
      
      <!--Exclude any .less files beginning with an '_' from being compiled as a convention, also exclude all less files from the obj directories -->
      <LessFiles Include="$(ProjectDir)\Content\*.less"
                 Exclude="$(ProjectDir)\Content\_*.less" />
    </ItemGroup>

    <CompileLess
      LessFiles="@(LessFiles)" />
  </Target>

  <Target Name="custom-tsconfig-->tsc"
          Condition="'$(BuildingInsideVisualStudio)' != 'true'"
          AfterTargets="CompileTypeScriptWithTSConfig">
    <ItemGroup>
      <CustomTSConfigs 
        Include="$(ProjectDir)**\*custom.tsconfig.json" 
        Exclude="$(ProjectDir)**\obj\**;
                 $(ProjectDir)**\bin\**;"/>
    </ItemGroup>

    <Exec Condition="'@(CustomTSConfigs)' != ''" Command="&quot;$(MSBuildProgramFiles32)\Microsoft SDKs\TypeScript\2.2\tsc.exe&quot; --project %(CustomTSConfigs.FullPath) "/>
 </Target>

  <!-- Suppress the TypeScript compile phase if we are building a linked project -->
  <!--<Target Name="CompileTypeScript" Condition="'$(LinkedBuild)' == 'true'" />-->

  <!-- 
    Debugging   
    msbuild Web.Foundation.csproj /target:_ItemGroupDebug
  -->
  <Target Name="_ItemGroupDebug">
    <!--<Message Text="AssemblyName: $(AssemblyName) (Enable content link: $(EnableContentLink))" />
    <Message Text="$([System.IO.Path]::GetFullPath('$(DependenciesDirectory)'))" />
    <Message Text="$([System.IO.Path]::GetFullPath('$(ProjectDir)'))" />
    <Message Text="Referenced web module: %(ReferencedWebModules.Identity)" />-->
    <!--<Message Condition="'%(AllDependencyContent.IsReferenced)' == 'true'" Text="
Identity:                 %(AllDependencyContent.Identity) 
RecursiveDir:             %(AllDependencyContent.RecursiveDir) 
FullPath:                 %(AllDependencyContent.FullPath) 
DependenciesRelativePath: %(AllDependencyContent.DependenciesRelativePath)
ProjectRelativePath:      %(AllDependencyContent.ProjectRelativePath)            
Link:                     %(AllDependencyContent.Link)
IsReferenced:             %(AllDependencyContent.IsReferenced)
RegexEscapedIdentity:     %(AllDependencyContent.RegexEscapedIdentity)
RegexContentPattern:      %(AllDependencyContent.RegexContentPattern)
NestedWeb:                %(AllDependencyContent.ContentIsNestedWeb)
ContentIsNonTransitive:   %(AllDependencyContent.ContentIsNonTransitive)
GitModule:                %(AllDependencyContent.GitModule)
Module:                   %(AllDependencyContent.Module)
Type:                     %(AllDependencyContent.Type)" />

    <Message Text="
WebModuleText:            $(WebModuleText) "
    />-->

    
    
    
    <!--<Message Text="ExternalTypeScript: %(ExternalTypeScript.RelativePath)%(Filename)%(Extension)" />    
    <Message Text="AspxContent: %(AspxContent.RelativePath)%(Filename)%(Extension)" />-->    
  </Target>
</Project>