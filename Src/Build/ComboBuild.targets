<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" 
         ToolsVersion="14.0"
         DefaultTargets="BuildAndPackage"
         InitialTargets="DefaultContextProperties;"
         TreatAsLocalProperty="SolutionRoot;AssemblyVersion">


  <!-- Server build property setup -->
  <PropertyGroup Condition="'$(BUILD_BUILDURI)' != ''">
    <SolutionRoot Condition="'$(BUILD_SOURCESDIRECTORY)' != ''">$(BUILD_SOURCESDIRECTORY)</SolutionRoot>
    <ArtifactStagingDirectory Condition="'$(ArtifactStagingDirectory)' == ''">$(Build_ArtifactStagingDirectory)</ArtifactStagingDirectory>
  </PropertyGroup>

  <!-- Desktop build property setup -->
  <PropertyGroup Condition="'$(BUILD_BUILDURI)' == ''">
    <SolutionRoot Condition="'$(SolutionRoot)' == ''">$(MSBuildStartupDirectory)</SolutionRoot>
    <ArtifactStagingDirectory Condition="'$(ArtifactStagingDirectory)' == ''">$(SolutionRoot)_ArtifactStaging</ArtifactStagingDirectory>
  </PropertyGroup>

  <PropertyGroup>
    <BuildInParallel Condition="'$(BuildInParallel)' != 'false' And '$(MSBuildNodeCount)' &gt; '1'">true</BuildInParallel>
    
    <!--Test configuration-->
    <RunTest Condition="'$(RunTest)' == ''">true</RunTest>
    <RunIntegrationTests Condition="'$(RunIntegrationTests)' == ''">false</RunIntegrationTests>
    <CodeCoverage Condition="'$(CodeCoverage)' == ''">true</CodeCoverage>
    <RunCodeAnalysis>$(RunCodeAnalysisSetting)</RunCodeAnalysis>
    <RunCodeAnalysis Condition="'$(IsCustomBuild)' == 'true'">false</RunCodeAnalysis>

    <!-- Local for factory generation -->
    <!--
    <LocalExpertBinariesDirectory>$(SolutionRoot)..\ExpertBinaries\</LocalExpertBinariesDirectory>
    <LocalExpertBinariesDirectory>$([System.IO.Path]::GetFullPath( '$(LocalExpertBinariesDirectory)' ))</LocalExpertBinariesDirectory>
-->
    <BuildInfrastructureDirectory>$([System.IO.Path]::GetDirectoryName($([System.IO.Path]::GetDirectoryName($([System.IO.Path]::GetDirectoryName($(MSBuildThisFileDirectory)))))))</BuildInfrastructureDirectory>
    <PackageScriptsDirectory>$(BuildInfrastructureDirectory)\Src\Package\</PackageScriptsDirectory>
    <BuildScriptsDirectory>$(BuildInfrastructureDirectory)\Src\Build\</BuildScriptsDirectory>
    <BuildToolsDirectory>$(BuildInfrastructureDirectory)\Src\Build.Tools\</BuildToolsDirectory>
    <ExpertSourceDirectory>$(LocalExpertBinariesDirectory)ExpertSource\</ExpertSourceDirectory>
    <ProductManifestPath>$(BuildInfrastructureDirectory)\ExpertManifest.xml</ProductManifestPath>
    
    <SolutionRoot Condition="'$(SolutionRoot)' != '' and !HasTrailingSlash('$(SolutionRoot)')">$(SolutionRoot)\</SolutionRoot>

    <!-- Enables the use of a shared dependency directory to speed up the build -->
    <UseSharedDependencyDirectory Condition="'$(UseSharedDependencyDirectory)' == ''">false</UseSharedDependencyDirectory>
    <SharedDependencyDirectory Condition="'$(SharedDependencyDirectory)' == ''">$(SolutionRoot)Dependencies\</SharedDependencyDirectory>

    <TfvcDropLocation>\\dfs.aderant.com\expertsuite\dev\vnext</TfvcDropLocation>
    <DropLocation Condition="'$(DropLocationRoot)' == ''">$(DropLocation)</DropLocation>


    <!-- Defines the dynamic project file which contains all projects within this build -->
    <BranchBuildProject Condition="'$(BranchBuildProject)' == ''">$(SolutionRoot)BranchBuild.proj</BranchBuildProject>

    <IsComboBuild>true</IsComboBuild>
    <ComboBuildType Condition="'$(ComboBuildType)' != ''">$(ComboBuildType)</ComboBuildType>
    <DownStreamType Condition="'$(DownStreamType)' != ''">$(DownStreamType)</DownStreamType>
  </PropertyGroup>

  <Import Project="$(BuildScriptsDirectory)Aderant.Build.Common.targets" />

  <!-- Contains the branch build configuration -->
  <!--<Import Project="$(ModuleList)" />-->

  <!--<ItemGroup>
    <ModulesInBuild Include="@(Modules)" />
  </ItemGroup>-->

  <Target Name="RunBuild">

  </Target>


  <PropertyGroup>
    <BuildAndPackageDependsOn>
      PrepareBuildEnvironment;
      <!--InitializeBuildVariables;-->
      CreateParallelBuildProject;
      GetAllModuleDependencies;
      <!--BuildModules;
      GetProduct;
      ZipProduct;-->
    </BuildAndPackageDependsOn>
  </PropertyGroup>

  <Target Name="CreateParallelBuildProject">

    <ItemGroup>
      <ExcludePaths Include="$(BuildSystemDirectory)" />
    </ItemGroup>

    <!-- Builds the dynamic project file to control the build sequence -->
    <ParallelBuildProjectFactory
      ContextFileName="$(ContextFileName)"
      ModulesDirectory="$(SolutionRoot)"
      ExcludedModules="Workflow.Integration.Samples;Workflow.Samples;Workflow.TeamManager;Dependencies;Packages;Applications.Marketing;Applications.DocuDraftAddIn;Web.Foundation;Web.Presentation;Web.OTG;SDK.Database;Build.Infrastructure"
      TfvcChangeset="$(TfvcChangeset)"
      TfvcBranch="$(TfvcBranch)"
      InstanceFile="$(BranchBuildProject)"
      GroupOrchestrationFile="$(MSBuildThisFileDirectory)ComboBuild.Core.targets"
      BeforeProjectFile="$(MSBuildThisFileDirectory)ComboBuild.PrepareForBuild.targets"
      AfterProjectFile="$(MSBuildThisFileDirectory)ComboBuild.AfterBuild.targets"
      ExcludePaths="@(ExcludePaths)">
      <Output TaskParameter="ModulesInThisBuild" ItemName="ModulesInBuild"/>
    </ParallelBuildProjectFactory>

    <Error Condition="!Exists('$(BranchBuildProject)')" Text="$(BranchBuildProject) does not exist." />
  </Target>


  <Target Name="GetAllModuleDependencies"
          Condition="'$(UseSharedDependencyDirectory)' == 'true'">
   
    <!-- As we are in a build all we can get all of the dependencies in a batch operation -->
    <Message Text="Getting dependencies for build." />

    <Delete Files="$(SolutionRoot)\paket.dependencies" ContinueOnError="true" />
    <Delete Files="$(SolutionRoot)\paket.lock" ContinueOnError="true" />

    <GetDependencies
      ProductManifest="$(ProductManifestPath)"
      ModulesRootPath="$(SolutionRoot)"
      DependenciesDirectory="$(SharedDependencyDirectory)"
      DropPath="$(TfvcDropLocation)"
      ModulesInBuild="@(ModulesInBuild)" />
    
    
    <Message Text="Finished GetDependencies" />

    <ItemGroup>
      <Files Include="$(SharedDependencyDirectory)**\*" />
    </ItemGroup>

    <ItemGroup>
      <ModuleDirectories Include="@(ModulesInBuild->'$(SolutionRoot)%(Identity)')"
                         Exclude="$(SolutionRoot).git" />
    </ItemGroup>

    <MakeSymlink
      Link="%(ModuleDirectories.FullPath)\Dependencies"
      Target="$(SharedDependencyDirectory)"
      Type="D" 
      FailIfLinkIsDirectoryWithContent="true" />

    <MakeSymlink
      Link="%(ModuleDirectories.FullPath)\packages"
      Target="$(SharedDependencyDirectory)\packages"
      Type="D"
      FailIfLinkIsDirectoryWithContent="true" />

    <!-- 
        TFS: 122744
        We delete the cmsmsg files here. I don't think this is "correct" as it makes the build system
        aware of what it's building but there is a frustrating interplay here. If you resume the build from a location after the
        production of the message file(s) then the build can fail on some application module builds. By delete the msg file from 
        dependency directory it prevents the TextTranslator loading a message file while unit tests are running and then having those tests fail
        as the test are generally written to assume no message file is available and so don't expect to find translated strings.
      -->
    <ItemGroup>
      <MessageFiles Include="$(SharedDependencyDirectory)\cmsmsg*.msg;" />
    </ItemGroup>

    <Delete Files="@(MessageFiles)" />


    <!--
    Build the global search path list. We pass this list to ResolveAssemblyReferences to augment the standard search paths
    This is done here, once for performance rather than in the module targets where we would end up scanning the shared directory far too often
    -->
    <ItemGroup>
      <AllAssemblyFiles Include="$(SharedDependencyDirectory)\**\*.dll;$(SharedDependencyDirectory)\**\*.exe" />
      <DependencySearchPaths Include="@(AllAssemblyFiles->'%(RootDir)%(Directory)'->Distinct())" />
    </ItemGroup>

    <PropertyGroup>
      <!-- Convert the array to a scalar property so it can be passed downstream -->
      <DependencySearchPaths>@(DependencySearchPaths)</DependencySearchPaths>
    </PropertyGroup>

    <Message Text="End of GetAllModuleDependencies"/>
  </Target>


  <Target Name="BeforeGetAllModuleDependencies" BeforeTargets="CreateParallelBuildProject">
    <Exec Command="rmdir /q /s $(SharedDependencyDirectory)" />

    <!--<RunPowerShell
      Command="$(BuildScriptsDirectory)\CleanSymlinks.ps1 &quot;$(SolutionRoot)&quot;">
    </RunPowerShell>-->

    <!--<MakeDir Directories="$(SharedDependencyDirectory)" />-->
  </Target>


  <!--<Target Name="ValidateBranchConfiguration" BeforeTargets="GetAllModuleDependencies">

    <ItemGroup>
      <ThirdPartyFiles Include="$(SolutionRoot)ThirdParty\**\bin\*.dll" />
    </ItemGroup>

    -->
  <!-- 
      Validates that we have no duplicated third party assemblies
      The build and packaging system does not support multiple versions of the same assembly with the same file name.
    --><!--
    <Message Text="Validating dependencies for build." />
    
    <DependencyChecker
      Files="@(ThirdPartyFiles)" />

    --><!--
      Validates that we have no misconfigured build configurations in this branch
    --><!--
    <Message Text="Validating build project files." />
    <BuildConfigurationCheck
      ProjectFiles="@(ModulesInBuild->'%(FullPath)\Build\TFSBuild.proj')" />
    
  </Target>



  <Target Name="Version" AfterTargets="GetAllModuleDependencies">
    <CallTarget Targets="SetBuildNumbers" />
  </Target>

  --><!-- Override the the Team Build hook -->
  <!--
  <Target Name="AfterDropBuild">
    <Message Text="After drop build" />
  </Target>

      -->

  <PropertyGroup>
    <InitialTargetsDependsOn>
      SetEnvironmentVariables
    </InitialTargetsDependsOn>
  </PropertyGroup>

  <Target Name="SetEnvironmentVariables">
    <!-- 
      As part of our builds, quite a few projects copy files to the binaries directory or other locations.  
      These can be anything from image files to test scripts.  To have our builds complete more quickly, we use the multi-process option (/maxcpucount) of msbuild to build projects in parallel.
      This all sounds normal, so what's the problem?  In a large team, people will sometimes inadvertently add statements to different project files that copy files to the same destination.  
      When those project files have no references to each other, directly or indirectly, msbuild may build them in parallel.  
      If it does happen to run those projects in parallel on different nodes and the copies happen at the same time, the build breaks because one copy succeeds and one fails.  
      Since the timing is not going to be the same on every build, the result is random build breaks. Build breaks suck. They drain the productivity of the team and are frustrating.
      
      There also appears to be a race condition inside MS Build that we come across from time to time where the same destination path is used in more than one copy.
      
      Consider this log snippet
      
   441>_CopyFilesMarkedCopyLocal:
         Copying file from "e:\B\90\7659\src\Libraries.Entities.Bill\packages\ThirdParty.NHibernate\lib\NHibernate.xml" to "..\..\Bin\Test\NHibernate.xml".
       _CopyOutOfDateSourceItemsToOutputDirectory:
         Creating directory "..\..\Bin\Test\Installation\CmsDbScripts".
         Copying file from "e:\B\90\7659\src\Libraries.Entities.Bill\Src\Aderant.Bill.Library\Installation\CmsDbScripts\BillModel_InquiryGetMatterAgingColumnLabels.sql" to "..\..\Bin\Test\Installation\CmsDbScripts\BillModel_InquiryGetMatterAgingColumnLabels.sql".
         Copying file from "e:\B\90\7659\src\Libraries.Entities.Bill\Src\Aderant.Bill.Library\Installation\CmsDbScripts\BillModel_InquiryMatterArAging.sql" to "..\..\Bin\Test\Installation\CmsDbScripts\BillModel_InquiryMatterArAging.sql".
         Copying file from "e:\B\90\7659\src\Libraries.Entities.Bill\Src\Aderant.Bill.Library\Installation\CmsDbScripts\BillModel_InquiryMatterWipAging.sql" to "..\..\Bin\Test\Installation\CmsDbScripts\BillModel_InquiryMatterWipAging.sql".
   440>_CopyOutOfDateSourceItemsToOutputDirectory:
         Copying file from "e:\B\90\7659\src\Libraries.Entities.Bill\Src\Aderant.Bill.Library\Installation\CmsDbScripts\BillModel_InquiryGetMatterAgingColumnLabels.sql" to "..\..\Bin\Test\Installation\CmsDbScripts\BillModel_InquiryGetMatterAgingColumnLabels.sql".
         Copying file from "e:\B\90\7659\src\Libraries.Entities.Bill\Src\Aderant.Bill.Library\Installation\CmsDbScripts\BillModel_InquiryMatterArAging.sql" to "..\..\Bin\Test\Installation\CmsDbScripts\BillModel_InquiryMatterArAging.sql".
   441>CopyFilesToOutputDirectory:
         Copying file from "obj\Release\UnitTest.Bill.Library.dll" to "..\..\Bin\Test\UnitTest.Bill.Library.dll".
         UnitTest.Bill.Library -> e:\B\90\7659\src\Libraries.Entities.Bill\Bin\Test\UnitTest.Bill.Library.dll
         Copying file from "obj\Release\UnitTest.Bill.Library.pdb" to "..\..\Bin\Test\UnitTest.Bill.Library.pdb".
   440>C:\Program Files (x86)\MSBuild\14.0\bin\Microsoft.Common.CurrentVersion.targets(4106,5): error MSB3021: Unable to copy file "e:\B\90\7659\src\Libraries.Entities.Bill\Src\Aderant.Bill.Library\Installation\CmsDbScripts\BillModel_InquiryMatterArAging.sql" to "..\..\Bin\Test\Installation\CmsDbScripts\BillModel_InquiryMatterArAging.sql". Access to the path '..\..\Bin\Test\Installation\CmsDbScripts\BillModel_InquiryMatterArAging.sql' is denied. [e:\B\90\7659\src\Libraries.Entities.Bill\Test\IntegrationTest.Bill.Library\IntegrationTest.Bill.Library.csproj]
         Copying file from "e:\B\90\7659\src\Libraries.Entities.Bill\Src\Aderant.Bill.Library\Installation\CmsDbScripts\BillModel_InquiryMatterWipAging.sql" to "..\..\Bin\Test\Installation\CmsDbScripts\BillModel_InquiryMatterWipAging.sql".
         
      There are two nodes running, 440 and 441. 
      For some reason both 441 and 440 schedule the copy of BillModel_InquiryMatterWipAging.sql to the output even though a node should only work on a single target at a time
      and thus a single node should be processing the source items of a project at any given time.
      -->

    <ItemGroup>
      <EnvironmentVariable Include="MSBUILDALWAYSRETRY">
        <Value>1</Value>
      </EnvironmentVariable>
    </ItemGroup>

    <SetEnvironmentVariable Variables="@(EnvVariable)" />

  </Target>


  <Target Name="DefaultContextProperties" DependsOnTargets="$(InitialTargetsDependsOn)">

    <DefaultContextProperties
        ContextFileName="$(ContextFileName)"
        WaitForDebugger="$(WaitForDebugger)">
      <Output TaskParameter="IsDesktopBuild" PropertyName="IsDesktopBuild" />
      <Output TaskParameter="BuildSystemDirectory" PropertyName="BuildSystemDirectory" />
    </DefaultContextProperties>

  </Target>
  

  <Target Name="BuildAndPackage" DependsOnTargets="$(BuildAndPackageDependsOn)">
    <!-- 
      To invoke this target on the desktop 
      msbuild TFSBuild.proj @TFSBuild.rsp /p:DropLocation=\\na.aderant.com\expertsuite\<branch> /nr:false
    -->

    <Message Text="==========================================" Importance="High" />
    <Message Text="Build queue..."                             Importance="High" />
    <Message Text="%(ModulesInBuild.FullPath)"                 Importance="High" />
    <Message Text="==========================================" Importance="High" />

    <CallTarget Targets="BuildModulesParallel" />
  </Target>


  <!--
    ==========================================================================================
    This target will build the modules in the branch in parallel where possible.
    For parallel builds to work reliably it is important that project references are used so MS Build can calculate the
    build order of projects within the module correctly.
    ==========================================================================================
  -->
  <Target Name="BuildModulesParallel">
    
    <PropertyGroup>
      <CommonBuildProperties>
        BuildAll=true;
        BuildNumber=$(BuildNumber);
        TfsBuildNumber=$(BuildNumber);
        BuildScriptsDirectory=$(BuildScriptsDirectory);
        ProductManifestPath=$(ProductManifestPath);
        BuildToolsDirectory=$(BuildToolsDirectory);
        UseSharedDependencyDirectory=$(UseSharedDependencyDirectory);
        SharedDependencyDirectory=$(SharedDependencyDirectory);
        FileVersion=$(FileVersion);
        AssemblyVersion=$(AssemblyVersion);
        BuildFlavor=$(BuildFlavor);
        EXPERT_BUILD_DIRECTORY=$(MSBuildThisFileDirectory)..\;
        ArtifactStagingDirectory=$(ArtifactStagingDirectory);
        AdditionalAssemblySearchPaths=$(DependencySearchPaths);
        CustomAfterMicrosoftCSharpTargets=$(CustomAfterMicrosoftCSharpTargets);
        CustomAfterMicrosoftCommonTargets=$(CustomAfterMicrosoftCommonTargets);
        CopyToDropEnabled=true;
        CompileBuildSystem=false;
        IsComboBuild=$(IsComboBuild);
      </CommonBuildProperties>
    </PropertyGroup>

    <Message Text="$(CommonBuildProperties)" />

    <Error Condition="!Exists('$(BranchBuildProject)')" Text="Did not find BranchBuild.proj "/>

    <MSBuild Projects="$(BranchBuildProject)"
             Properties="$(CommonBuildProperties)"
             StopOnFirstFailure="true"
             BuildInParallel="$(BuildInParallel)" />

  </Target>


  <Target Name="Package" AfterTargets="BuildAndPackage">
    <OnError ExecuteTargets="OnBuildBreak" />
  </Target>

  <!--
    ==========================================================================================
    Zip output
    ==========================================================================================
  -->
  <Target Name="ZipProduct" BeforeTargets="Package">

    <PropertyGroup>
      <LocalExpertBinariesDirectory>$(ArtifactStagingDirectory)</LocalExpertBinariesDirectory>
      <ZipFileDirectory Condition="'$(ZipFileDirectory)' == ''">$(ArtifactStagingDirectory)</ZipFileDirectory>
      <ZipFile>$(ZipFileDirectory)\ExpertBinaries.zip</ZipFile>
      <EliteEnterpriseZipFile>$(ZipFileDirectory)\ExpertEEIntegrationBinaries.zip</EliteEnterpriseZipFile>
      <LicenseZipFile>$(ZipFileDirectory)\LicenseGenerator.zip</LicenseZipFile>
      <RegistrationZipFile>$(ZipFileDirectory)\RegistrationService.zip</RegistrationZipFile>
      <EliteEnterpriseBinOverrideDirectory>$(LocalExpertBinariesDirectory)\ExpertSource\EEBin</EliteEnterpriseBinOverrideDirectory>
    </PropertyGroup>
    
    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Zipping build output"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">
      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>

    <Message Text="Zipping product files"/>

    <!-- Create ItemGroup used in Zip task.-->
    <ItemGroup>
      <SharedExclusions
        Include="$(LocalExpertBinariesDirectory)\ExpertSource\Internal\**\*.*;
                 $(LocalExpertBinariesDirectory)\**\_PublishedWebsites\**\*;
                 $(LocalExpertBinariesDirectory)\**\LexisNexis*.*;
                 $(LocalExpertBinariesDirectory)\**\iManage*.*;
                 $(LocalExpertBinariesDirectory)\**\System.dll*;
                 $(LocalExpertBinariesDirectory)\**\System.Data.dll;
                 $(LocalExpertBinariesDirectory)\**\System.Drawing*.dll;
                 $(LocalExpertBinariesDirectory)\**\System.Windows.Forms*.dll;
                 $(LocalExpertBinariesDirectory)\**\System.Xml*dll*;   
                 $(LocalExpertBinariesDirectory)\**\Microsoft.TeamFoundation.*dll*;
                 $(LocalExpertBinariesDirectory)\**\*UnitTest*;
                 $(LocalExpertBinariesDirectory)\**\TestLicenseRegistration*;
                 $(LocalExpertBinariesDirectory)\**\*CodeAnalysis*;
                 $(LocalExpertBinariesDirectory)\**\*.deploy.cmd;   
                 $(LocalExpertBinariesDirectory)\**\*.deploy-readme.txt;
                 $(LocalExpertBinariesDirectory)\**\*.SetParameters.*;
                 $(LocalExpertBinariesDirectory)\**\*.BuildInfo.config;
                 $(LocalExpertBinariesDirectory)\**\DropFolderBuildNumbers.txt;" />

      <!-- Group of the roles shared between expert and elite -->
      <SharedRoles
        Include="$(LocalExpertBinariesDirectory)\**\commonapplications.role.xml;
                 $(LocalExpertBinariesDirectory)\**\configuration.role.xml;
                 $(LocalExpertBinariesDirectory)\**\customworkflows.role.xml;
                 $(LocalExpertBinariesDirectory)\**\firmcontrol.role.xml;
                 $(LocalExpertBinariesDirectory)\**\messaging.role.xml;
                 $(LocalExpertBinariesDirectory)\**\notes.role.xml;
                 $(LocalExpertBinariesDirectory)\**\queryservice.role.xml;
                 $(LocalExpertBinariesDirectory)\**\security.role.xml;
                 $(LocalExpertBinariesDirectory)\**\webcore.role.xml;
                 $(LocalExpertBinariesDirectory)\**\workflow.role.xml;
                 $(LocalExpertBinariesDirectory)\**\workflowauthoring.role.xml" />

      <!-- Group of the roles that should be elite only -->
      <EliteRoles
        Include="$(LocalExpertBinariesDirectory)\**\eliteintegration.role.xml;
                 $(LocalExpertBinariesDirectory)\**\matterplanningelite.role.xml" />

      <!-- Create a group of roles to exclude from elite (all roles minus the elite roles and shared roles) -->
      <EliteRoleExclusions
        Include="$(LocalExpertBinariesDirectory)\**\*.role.xml"
        Exclude="@(SharedRoles);@(EliteRoles)"/>

      <EliteOverrideFiles Include="$(EliteEnterpriseBinOverrideDirectory)\**\*.*" />

      <EliteDocuments Include="$(LocalExpertBinariesDirectory)\Elite Documentation\**\*.*"/>
      <Documents Include="$(LocalExpertBinariesDirectory)\Documentation\**\*.*"/>

      <ZipSourceFiles
        Include="$(LocalExpertBinariesDirectory)\**\*.*"
        Exclude="@(SharedExclusions);@(EliteRoles);@(EliteOverrideFiles);@(EliteDocuments)" />
      <ZipLicenseGeneratorFiles
        Include="$(LocalExpertBinariesDirectory)\ExpertSource\Internal\LicenseGenerator\*.*" />
      <ZipRegistrationServiceFiles
        Include="$(LocalExpertBinariesDirectory)\ExpertSource\Internal\RegistrationService\*.*" />
    </ItemGroup>

    <MakeDir
      Directories="$(ZipFileDirectory)"/>

    <!-- Create ZIP for ExpertSource -->
    <MSBuild.Community.Tasks.Zip
      Files="@(ZipSourceFiles)"
      ZipFileName="$(ZipFile)"
      WorkingDirectory="$(LocalExpertBinariesDirectory)"
      ParallelCompression="false" />

    <!-- Replace files in ExpertSource with the Elite bin folder overrides, used for things like message files and help. --><!--
    <Copy
      SourceFiles="@(EliteOverrideFiles)"
      DestinationFiles="@(EliteOverrideFiles->'$(LocalExpertBinariesDirectory)\ExpertSource\%(RecursiveDir)%(Filename)%(Extension)')" />

    --><!-- Essentially rename Elite.Help to Expert.Help --><!--
    <Copy
      SourceFiles="$(LocalExpertBinariesDirectory)\ExpertSource\Help\Elite.Help.sfx"
      DestinationFiles="$(LocalExpertBinariesDirectory)\ExpertSource\Help\Expert.Help.sfx" />

    <Delete
      Files="$(LocalExpertBinariesDirectory)\ExpertSource\Help\Elite.Help.sfx" />

    --><!-- Move the Elite specific docs into the Documents folder--><!--
    <Delete
      Files="@(Documents)" />

    <Copy
      SourceFiles="@(EliteDocuments)"
      DestinationFiles="@(EliteDocuments->'$(LocalExpertBinariesDirectory)\Documentation\%(RecursiveDir)%(Filename)%(Extension)')" />

    --><!-- This item group must go after the copy so that any moved files are included --><!--
    <ItemGroup>
      <ZipEliteEnterpriseSourceFiles
        Include="$(LocalExpertBinariesDirectory)\**\*.*"
        Exclude="@(SharedExclusions);@(EliteRoleExclusions);@(EliteDocuments)" />
    </ItemGroup>

    --><!-- Create ZIP for Elite Enterprise ExpertSource --><!--
    <MSBuild.Community.Tasks.Zip
      Files="@(ZipEliteEnterpriseSourceFiles)"
      ZipFileName="$(EliteEnterpriseZipFile)"
      WorkingDirectory="$(LocalExpertBinariesDirectory)"
      ParallelCompression="false" />

    --><!-- Create ZIP for LicenseGenerator --><!--
    <MSBuild.Community.Tasks.Zip
      Files="@(ZipLicenseGeneratorFiles)"
      ZipFileName="$(LicenseZipFile)"
      WorkingDirectory="$(LocalExpertBinariesDirectory)\ExpertSource\Internal\LicenseGenerator"
      ParallelCompression="false" />

    --><!-- Create ZIP for RegistrationService --><!--
    <MSBuild.Community.Tasks.Zip
      Files="@(ZipRegistrationServiceFiles)"
      ZipFileName="$(RegistrationZipFile)"
      WorkingDirectory="$(LocalExpertBinariesDirectory)\ExpertSource\Internal\RegistrationService"
      ParallelCompression="false" />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />-->
  </Target>

  
  <!--
  ==========================================================================================
  Package the built modules and place in this builds output folder on the drop.
  ==========================================================================================
  --><!--
  <Target Name="GetProduct" BeforeTargets="ZipProduct">

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      Message="Package Product"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildURI)">

      <Output
        TaskParameter="id"
        PropertyName="BuildStepId" />
    </BuildStep>

    <MakeDir Directories="$(LocalExpertBinariesDirectory)"
             Condition="!Exists('$(LocalExpertBinariesDirectory)')" />

    <Exec ContinueOnError="false"
          IgnoreExitCode="false"
          Command="Powershell -noprofile $(PackageScriptsDirectory)GetProduct.ps1 -productManifestPath $(ProductManifestPath) -dropRoot $(BuildAllDropPath) -binariesDirectory $(LocalExpertBinariesDirectory) -systemMapConnectionString '$(ExpertDatabaseConnectionStringForSystemMap)' -getDebugFiles $true"
          WorkingDirectory="$(PackageScriptsDirectory)" />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />
  </Target>
 

  <UsingTask
    TaskName="MergeParameters"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="$(CodeTaskFactoryAssembly)">
    <ParameterGroup>
      <Source ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Target ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" Output="true" />
      <MergeResult ParameterType="Microsoft.Build.Framework.ITaskItem[]" Output="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="System.Core" />
      <Reference Include="System.Xml" />
      <Reference Include="System.Xml.Linq "/>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Collections.Generic" />
      <Using Namespace="System.Linq" />
      <Using Namespace="System.Xml.Linq" />
      <Using Namespace="System.Text.RegularExpressions" />
      <Code>
        <![CDATA[
  List<ITaskItem> items = new List<ITaskItem>(Target);
  
  foreach (var sourceItem in Source) {
      var sourceKey = sourceItem.ItemSpec.Split('=')[0];
    
      bool add = true;
    
      foreach (var item in Target) {
          var itemKey = item.ItemSpec.Split('=')[0];
      
          if (itemKey == sourceKey) {
            Log.LogMessage("ItemGroup already contains key: " + itemKey, null);
            add = false;
            break;
          }
      }
    
      if (add) {
          items.Add(sourceItem);
      }    
  } 
  
  MergeResult = items.ToArray(); 
]]>
      </Code>
    </Task>
  </UsingTask>-->
  
</Project>