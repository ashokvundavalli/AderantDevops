<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" 
         ToolsVersion="14.0"
         DefaultTargets="BuildAndPackage"
         InitialTargets="SetPropertiesFromContext;"
         TreatAsLocalProperty="SolutionRoot;BuildFlavor">

  <!-- Server build property setup -->
  <PropertyGroup Condition="'$(BUILD_BUILDURI)' != ''">
    <SolutionRoot Condition="'$(BUILD_SOURCESDIRECTORY)' != ''">$(BUILD_SOURCESDIRECTORY)</SolutionRoot>
  </PropertyGroup>

  <!-- Desktop build property setup -->
  <PropertyGroup Condition="'$(BUILD_BUILDURI)' == ''">
    <SolutionRoot Condition="'$(SolutionRoot)' == ''">$(MSBuildStartupDirectory)</SolutionRoot>
  </PropertyGroup>

  <PropertyGroup>
    <!--Ensure root path is consistent-->
    <SolutionRoot Condition="'$(SolutionRoot)' != '' and !HasTrailingSlash('$(SolutionRoot)')">$(SolutionRoot)\</SolutionRoot>

    <BuildInParallel Condition="'$(BuildInParallel)' != 'false' And '$(MSBuildNodeCount)' &gt; '1'">true</BuildInParallel>
    
    <!--Test configuration-->
    <RunTest Condition="'$(RunTest)' == ''">true</RunTest>
    <RunIntegrationTests Condition="'$(RunIntegrationTests)' == ''">false</RunIntegrationTests>
    <CodeCoverage Condition="'$(CodeCoverage)' == ''">true</CodeCoverage>
    <RunCodeAnalysis>$(RunCodeAnalysisSetting)</RunCodeAnalysis>
    <RunCodeAnalysis Condition="'$(IsCustomBuild)' == 'true'">false</RunCodeAnalysis>

    <!-- Local for factory generation -->
    <!--
    <LocalExpertBinariesDirectory>$(SolutionRoot)..\ExpertBinaries\</LocalExpertBinariesDirectory>
    <LocalExpertBinariesDirectory>$([System.IO.Path]::GetFullPath( '$(LocalExpertBinariesDirectory)' ))</LocalExpertBinariesDirectory>
-->
    <!-- Location to drop artifacts (packaged outputputs) -->
    <ArtifactStagingDirectory Condition="'$(ArtifactStagingDirectory)' == ''">$(SolutionRoot)_as\</ArtifactStagingDirectory>
    
    <!-- Location to drop outputs to share within the build -->
    <UseSharedDependencyDirectory Condition="'$(UseSharedDependencyDirectory)' == ''">false</UseSharedDependencyDirectory>
    <SharedDependencyDirectory Condition="'$(SharedDependencyDirectory)' == ''">$(ArtifactStagingDirectory)out\</SharedDependencyDirectory>

    <BuildInfrastructureDirectory>$([System.IO.Path]::GetDirectoryName($([System.IO.Path]::GetDirectoryName($([System.IO.Path]::GetDirectoryName($(MSBuildThisFileDirectory)))))))</BuildInfrastructureDirectory>
    <PackageScriptsDirectory>$(BuildInfrastructureDirectory)\Src\Package\</PackageScriptsDirectory>
    <BuildScriptsDirectory>$(BuildInfrastructureDirectory)\Src\Build\</BuildScriptsDirectory>
    <BuildToolsDirectory>$(BuildInfrastructureDirectory)\Src\Build.Tools\</BuildToolsDirectory>

    <!-- Defines the dynamic project file which contains all projects within this build -->
    <BranchBuildProject Condition="'$(BranchBuildProject)' == ''">$(SolutionRoot)BranchBuild.proj</BranchBuildProject>

    <CopyToDropEnabled>true</CopyToDropEnabled>
    <CopyToDropEnabled Condition="'$(IsDesktopBuild)' == 'false'">true</CopyToDropEnabled>
    <RunPackageProduct Condition="'$(CopyToDropEnabled)' == 'true'">true</RunPackageProduct>
  </PropertyGroup>

  <Import Project="$(BuildScriptsDirectory)Aderant.Build.Common.targets" />

  <PropertyGroup>
    <BuildAndPackageDependsOn>
      PrepareBuildEnvironment;
      <!--ArchiveStagingDirectory;-->
      CreatePipeline;
      ExecutePipeline;
      WriteStateFiles;
      PackageProduct;
      CopyToDrop;
    </BuildAndPackageDependsOn>
  </PropertyGroup>


  <Target Name="ArchiveStagingDirectory">
    <PowerShellScript
      Condition="Exists($(ArtifactStagingDirectory))"
      ScriptBlock='Move-Item -LiteralPath "$(ArtifactStagingDirectory)" -Destination ("$(SolutionRoot)\_as" + [DateTime]::UtcNow.ToFileTime()) -Verbose' />
  </Target>


  <Target Name="CreatePipeline">

    <ItemGroup>
      <ExcludePaths Condition="'$(BuildSystemInTestMode)' != 'true'" Include="$(BuildSystemDirectory)" />
      <ExcludePaths Include="Collections" />
      <ExcludePaths Include="GeneralLedger" />
      <ExcludePaths Include="Customization" />
    </ItemGroup>

    <!-- 
    ==========================================================================================
        Build Configurations
    ==========================================================================================
    -->
    <ItemGroup>
      <ConfigurationToBuild Condition="'$(BuildFlavor)' == 'Release'"
        Include="Release|Any CPU">
        <FlavorToBuild>Release</FlavorToBuild>
        <PlatformToBuild>Any CPU</PlatformToBuild>
      </ConfigurationToBuild>
      <ConfigurationToBuild Condition="'$(BuildFlavor)' == 'Debug'"
        Include="Debug|Any CPU">
        <FlavorToBuild>Debug</FlavorToBuild>
        <PlatformToBuild>Any CPU</PlatformToBuild>
      </ConfigurationToBuild>
    </ItemGroup>

    <!-- Builds the dynamic project file to control the build sequence -->
    <ParallelBuildProjectFactory
      ContextFileName="$(ContextFileName)"
      ModulesDirectory="$(SolutionRoot)"
      InstanceFile="$(BranchBuildProject)"
      GroupExecutionFile="$(MSBuildThisFileDirectory)ComboBuild.Core.targets"
      BeforeProjectFile="$(MSBuildThisFileDirectory)ComboBuild.Pre.targets"
      AfterProjectFile="$(MSBuildThisFileDirectory)ComboBuild.Post.targets"
      CommonProjectFile="$(MSBuildThisFileDirectory)ComboBuild.Common.proj"
      ExcludePaths="@(ExcludePaths)"
      ConfigurationToBuild="@(ConfigurationToBuild)">
      <Output TaskParameter="ModulesInThisBuild" ItemName="ModulesInBuild"/>
    </ParallelBuildProjectFactory>

    <Error Condition="!Exists('$(BranchBuildProject)')" Text="$(BranchBuildProject) does not exist." />

    <Message Condition="'$(IsDesktopBuild)' == 'false'" Text="##vso[task.uploadfile]$(BranchBuildProject)" />
  </Target>


  <Target Name="WriteStateFiles">
    <WriteBuildStateFile />
  </Target>


  <Target Name="GetAllModuleDependencies"
          Condition="'$(UseSharedDependencyDirectory)' == 'true'">
   
    <!-- As we are in a build all we can get all of the dependencies in a batch operation -->
    <Message Text="Getting dependencies for build." />

    <Delete Files="$(SolutionRoot)\paket.dependencies" ContinueOnError="true" />
    <Delete Files="$(SolutionRoot)\paket.lock" ContinueOnError="true" />

    <GetDependencies
      ProductManifest="$(ProductManifestPath)"
      ModulesRootPath="$(SolutionRoot)"
      DependenciesDirectory="$(SharedDependencyDirectory)"
      DropPath="$(TfvcDropLocation)"
      ModulesInBuild="@(ModulesInBuild)" />
    
    <Message Text="Finished GetDependencies" />

    <ItemGroup>
      <Files Include="$(SharedDependencyDirectory)**\*" />
    </ItemGroup>

    <ItemGroup>
      <ModuleDirectories Include="@(ModulesInBuild->'$(SolutionRoot)%(Identity)')"
                         Exclude="$(SolutionRoot).git" />
    </ItemGroup>

    <MakeSymlink
      Link="%(ModuleDirectories.FullPath)\Dependencies"
      Target="$(SharedDependencyDirectory)"
      Type="D" 
      FailIfLinkIsDirectoryWithContent="true" />

    <MakeSymlink
      Link="%(ModuleDirectories.FullPath)\packages"
      Target="$(SharedDependencyDirectory)\packages"
      Type="D"
      FailIfLinkIsDirectoryWithContent="true" />

    <!-- 
        TFS: 122744
        We delete the cmsmsg files here. I don't think this is "correct" as it makes the build system
        aware of what it's building but there is a frustrating interplay here. If you resume the build from a location after the
        production of the message file(s) then the build can fail on some application module builds. By delete the msg file from 
        dependency directory it prevents the TextTranslator loading a message file while unit tests are running and then having those tests fail
        as the test are generally written to assume no message file is available and so don't expect to find translated strings.
      -->
    <ItemGroup>
      <MessageFiles Include="$(SharedDependencyDirectory)\cmsmsg*.msg;" />
    </ItemGroup>

    <Delete Files="@(MessageFiles)" />

    <Message Text="End of GetAllModuleDependencies"/>
  </Target>


  <PropertyGroup>
    <InitialTargetsDependsOn>ValidateRequiredProperties</InitialTargetsDependsOn>
  </PropertyGroup>


  <Target Name="ValidateRequiredProperties">
    <Error Condition="'$(XamlBuildDropLocation)' == ''" Text="XamlBuildDropLocation is undefined" />
    <Error Condition="'$(ProductManifestPath)' == ''" Text="ProductManifestPath is undefined" />
  </Target>


  <Target Name="SetPropertiesFromContext" DependsOnTargets="$(InitialTargetsDependsOn)">

    <WaitForDebugger Wait="$(WaitForDebugger)" />

    <GetPropertiesFromContext
        ContextFileName="$(ContextFileName)"
        ArtifactStagingDirectory="$(ArtifactStagingDirectory)">
      <Output TaskParameter="IsDesktopBuild" PropertyName="IsDesktopBuild" />
      <Output TaskParameter="BuildSystemDirectory" PropertyName="BuildSystemDirectory" />
      <Output TaskParameter="BuildFlavor" PropertyName="BuildFlavor" />
    </GetPropertiesFromContext>

  </Target>
  

  <Target Name="BuildAndPackage" DependsOnTargets="$(BuildAndPackageDependsOn)">
  </Target>


  <!--
    ==========================================================================================
    This target will build the projects in the pipeline in parallel where possible.    
    ==========================================================================================
  -->
  <Target Name="ExecutePipeline">
    <PropertyGroup>
      <CommonBuildProperties>
        BuildInParallel=true;
        BuildNumber=$(BuildNumber);
        BuildScriptsDirectory=$(BuildScriptsDirectory);
        ProductManifestPath=$(ProductManifestPath);
        BuildToolsDirectory=$(BuildToolsDirectory);
        UseSharedDependencyDirectory=$(UseSharedDependencyDirectory);
        SharedDependencyDirectory=$(SharedDependencyDirectory);
        BuildFlavor=$(BuildFlavor);
        ArtifactStagingDirectory=$(ArtifactStagingDirectory);
        CustomAfterMicrosoftCSharpTargets=$(CustomAfterMicrosoftCSharpTargets);
        CustomAfterMicrosoftCommonTargets=$(CustomAfterMicrosoftCommonTargets);
        CompileBuildSystem=false;
      </CommonBuildProperties>
    </PropertyGroup>

    <Message Text="$(CommonBuildProperties)" />

    <Error Condition="!Exists('$(BranchBuildProject)')" Text="Did not find BranchBuild.proj "/>

    <MSBuild Projects="$(BranchBuildProject)"
             Properties="$(CommonBuildProperties);BuildEnabled=true"
             StopOnFirstFailure="true"
             BuildInParallel="$(BuildInParallel)" />

  </Target>

  <Target Name="PackageProduct" Condition="'$(RunPackageProduct)' == 'true'">
    <PropertyGroup>
      <LocalExpertBinariesDirectory>$(ArtifactStagingDirectory)product\</LocalExpertBinariesDirectory>
      <ExpertSourceDirectory>$(LocalExpertBinariesDirectory)ExpertSource\</ExpertSourceDirectory>
      <ProductArchiveFile>$(ArtifactStagingDirectory)package\Binaries.zip</ProductArchiveFile>
    </PropertyGroup>

    <MakeDir Directories="$(LocalExpertBinariesDirectory)"
             Condition="!Exists('$(LocalExpertBinariesDirectory)')" />

    <GetArtifactPaths
      IncludeGeneratedArtifacts="false">
      <Output TaskParameter="ArtifactPaths" ItemName="LocalPackagePaths" />
    </GetArtifactPaths>

    <!--
      Item lists cannot be concatenated with other strings so we need to fall back to CreateItem
      to force msbuild to expand all the wildcard characters so to get real file paths
    -->
    <CreateItem Include="@(LocalPackagePaths->'%(FullPath)\**\**')" PreserveExistingMetadata="true">
      <Output ItemName="LocalPackageFiles" TaskParameter="Include" />
    </CreateItem>

    <Exec ContinueOnError="false"
      IgnoreExitCode="false"
      Command="Powershell -noprofile $(PackageScriptsDirectory)GetProduct.ps1 -productManifestPath $(ProductManifestPath) -dropRoot $(XamlBuildDropLocation) -binariesDirectory $(LocalExpertBinariesDirectory) -getDebugFiles:1"
      WorkingDirectory="$(LocalExpertBinariesDirectory)" />

    <!--TODO: Should we teach GetProduct how to do this? What if we have crazy assembly rules we want to fire--> 
    <Copy SourceFiles="@(LocalPackageFiles)"
      DestinationFiles="@(LocalPackageFiles->'$(ExpertSourceDirectory)%(DestinationSubDirectory)%(RecursiveDir)%(Filename)%(Extension)')"
      UseHardlinksIfPossible="true">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites" />
    </Copy>

    <CheckForDoubleWrites FileList="@(FileWrites)" />

    <!-- Compress-Archive fails in a 32-bit process due to its naive implementation so we shell out to 7zip -->
    <!-- -bb1 for file logging -->
    <Exec Command="$(BuildToolsDirectory)7z.exe a $(ProductArchiveFile) $(LocalExpertBinariesDirectory)*" />

    <PropertyGroup>
      <CreateArchiveHashScript>
        $hash = Get-FileHash -LiteralPath "$(ProductArchiveFile)" -Algorithm SHA1 -Verbose | Select-Object -ExpandProperty Hash
        $hash = $hash.ToLower()
        $fn = [System.IO.Path]::GetFileName("$(ProductArchiveFile)")
        Set-Content -LiteralPath "$(ProductArchiveFile).sha1" -Value "$hash  $fn"
        Add-Content -LiteralPath "$(ProductArchiveFile)" -Value "$hash" -Stream "sha1"
      </CreateArchiveHashScript>

    </PropertyGroup>

    <PowerShellScript ScriptBlock="$(CreateArchiveHashScript)" />     
    
  </Target>


  <Target Name="CopyToDrop" Condition="'$(CopyToDropEnabled)' == 'true' And '$(PrimaryDropLocation)' != ''">

    <ItemGroup>
      <ArtifactPackage Include="$(ProductArchiveFile)">
        <ArtifactId>Product</ArtifactId>
        <ArtifactType>Branch</ArtifactType>
      </ArtifactPackage>
    </ItemGroup>

    <PublishArtifacts
      ArtifactStagingDirectory="$(ArtifactStagingDirectory)"
      AdditionalArtifacts="@(ArtifactPackage)"
      DestinationRootPath="$(PrimaryDropLocation)">
      <Output TaskParameter="ArtifactPaths" ItemName="ArtifactPaths" />
      <Output TaskParameter="LinkCommands" ItemName="LinkCommands" />
    </PublishArtifacts>

    <!--Tell TFS about the new artifacts so it can manage them -->
    <Message Text="%(LinkCommands.Identity)" />

    <Message Text="%(ArtifactPaths.Identity) --> %(ArtifactPaths.TargetPath)" />

    <!-- We ignore exit codes less than 4 as these codes indicate success -->
    <PropertyGroup>
      <CopyToDropCommand>
<![CDATA[
robocopy.exe "%(ArtifactPaths.Identity)" "%(ArtifactPaths.TargetPath)" * /MT /S /NDL /R:10 /NP /LOG:CopyToDrop.log /TEE        
IF %ERRORLEVEL% LEQ 4 EXIT /B 0
]]>
      </CopyToDropCommand>
    </PropertyGroup>

    <Exec Command="$(CopyToDropCommand)"
          WorkingDirectory="$(ArtifactStagingDirectory)" />

  </Target>

  <!--
    ==========================================================================================
    Zip output
    ==========================================================================================
  -->
  <Target Name="ZipProduct" BeforeTargets="Package" Condition="'$(NoMSBuildCommunityTasks)' != 'true'">

    <PropertyGroup>
      <LocalExpertBinariesDirectory>$(ArtifactStagingDirectory)</LocalExpertBinariesDirectory>
      <ZipFileDirectory Condition="'$(ZipFileDirectory)' == ''">$(ArtifactStagingDirectory)</ZipFileDirectory>
      <ZipFile>$(ZipFileDirectory)\ExpertBinaries.zip</ZipFile>
      <EliteEnterpriseZipFile>$(ZipFileDirectory)\ExpertEEIntegrationBinaries.zip</EliteEnterpriseZipFile>
      <LicenseZipFile>$(ZipFileDirectory)\LicenseGenerator.zip</LicenseZipFile>
      <RegistrationZipFile>$(ZipFileDirectory)\RegistrationService.zip</RegistrationZipFile>
      <EliteEnterpriseBinOverrideDirectory>$(LocalExpertBinariesDirectory)\ExpertSource\EEBin</EliteEnterpriseBinOverrideDirectory>
    </PropertyGroup>

    <Message Text="Zipping product files"/>

    <!-- Create ItemGroup used in Zip task.-->
    <ItemGroup>
      <SharedExclusions
        Include="$(LocalExpertBinariesDirectory)\ExpertSource\Internal\**\*.*;
                 $(LocalExpertBinariesDirectory)\**\_PublishedWebsites\**\*;
                 $(LocalExpertBinariesDirectory)\**\LexisNexis*.*;
                 $(LocalExpertBinariesDirectory)\**\iManage*.*;
                 $(LocalExpertBinariesDirectory)\**\System.dll*;
                 $(LocalExpertBinariesDirectory)\**\System.Data.dll;
                 $(LocalExpertBinariesDirectory)\**\System.Drawing*.dll;
                 $(LocalExpertBinariesDirectory)\**\System.Windows.Forms*.dll;
                 $(LocalExpertBinariesDirectory)\**\System.Xml*dll*;   
                 $(LocalExpertBinariesDirectory)\**\Microsoft.TeamFoundation.*dll*;
                 $(LocalExpertBinariesDirectory)\**\*UnitTest*;
                 $(LocalExpertBinariesDirectory)\**\TestLicenseRegistration*;
                 $(LocalExpertBinariesDirectory)\**\*CodeAnalysis*;
                 $(LocalExpertBinariesDirectory)\**\*.deploy.cmd;   
                 $(LocalExpertBinariesDirectory)\**\*.deploy-readme.txt;
                 $(LocalExpertBinariesDirectory)\**\*.SetParameters.*;
                 $(LocalExpertBinariesDirectory)\**\*.BuildInfo.config;
                 $(LocalExpertBinariesDirectory)\**\DropFolderBuildNumbers.txt;" />

      <!-- Group of the roles shared between expert and elite -->
      <SharedRoles
        Include="$(LocalExpertBinariesDirectory)\**\commonapplications.role.xml;
                 $(LocalExpertBinariesDirectory)\**\configuration.role.xml;
                 $(LocalExpertBinariesDirectory)\**\customworkflows.role.xml;
                 $(LocalExpertBinariesDirectory)\**\firmcontrol.role.xml;
                 $(LocalExpertBinariesDirectory)\**\messaging.role.xml;
                 $(LocalExpertBinariesDirectory)\**\notes.role.xml;
                 $(LocalExpertBinariesDirectory)\**\queryservice.role.xml;
                 $(LocalExpertBinariesDirectory)\**\security.role.xml;
                 $(LocalExpertBinariesDirectory)\**\webcore.role.xml;
                 $(LocalExpertBinariesDirectory)\**\workflow.role.xml;
                 $(LocalExpertBinariesDirectory)\**\workflowauthoring.role.xml" />

      <!-- Group of the roles that should be elite only -->
      <EliteRoles
        Include="$(LocalExpertBinariesDirectory)\**\eliteintegration.role.xml;
                 $(LocalExpertBinariesDirectory)\**\matterplanningelite.role.xml" />

      <!-- Create a group of roles to exclude from elite (all roles minus the elite roles and shared roles) -->
      <EliteRoleExclusions
        Include="$(LocalExpertBinariesDirectory)\**\*.role.xml"
        Exclude="@(SharedRoles);@(EliteRoles)"/>

      <EliteOverrideFiles Include="$(EliteEnterpriseBinOverrideDirectory)\**\*.*" />

      <EliteDocuments Include="$(LocalExpertBinariesDirectory)\Elite Documentation\**\*.*"/>
      <Documents Include="$(LocalExpertBinariesDirectory)\Documentation\**\*.*"/>

      <ZipSourceFiles
        Include="$(LocalExpertBinariesDirectory)\**\*.*"
        Exclude="@(SharedExclusions);@(EliteRoles);@(EliteOverrideFiles);@(EliteDocuments)" />
      <ZipLicenseGeneratorFiles
        Include="$(LocalExpertBinariesDirectory)\ExpertSource\Internal\LicenseGenerator\*.*" />
      <ZipRegistrationServiceFiles
        Include="$(LocalExpertBinariesDirectory)\ExpertSource\Internal\RegistrationService\*.*" />
    </ItemGroup>

    <MakeDir
      Directories="$(ZipFileDirectory)"/>

    <!-- Create ZIP for ExpertSource -->
    <MSBuild.Community.Tasks.Zip
      Files="@(ZipSourceFiles)"
      ZipFileName="$(ZipFile)"
      WorkingDirectory="$(LocalExpertBinariesDirectory)"
      ParallelCompression="false" />

    <!-- Replace files in ExpertSource with the Elite bin folder overrides, used for things like message files and help. -->
    <!--
    <Copy
      SourceFiles="@(EliteOverrideFiles)"
      DestinationFiles="@(EliteOverrideFiles->'$(LocalExpertBinariesDirectory)\ExpertSource\%(RecursiveDir)%(Filename)%(Extension)')" />

    -->
    <!-- Essentially rename Elite.Help to Expert.Help -->
    <!--
    <Copy
      SourceFiles="$(LocalExpertBinariesDirectory)\ExpertSource\Help\Elite.Help.sfx"
      DestinationFiles="$(LocalExpertBinariesDirectory)\ExpertSource\Help\Expert.Help.sfx" />

    <Delete
      Files="$(LocalExpertBinariesDirectory)\ExpertSource\Help\Elite.Help.sfx" />

    -->
    <!-- Move the Elite specific docs into the Documents folder-->
    <!--
    <Delete
      Files="@(Documents)" />

    <Copy
      SourceFiles="@(EliteDocuments)"
      DestinationFiles="@(EliteDocuments->'$(LocalExpertBinariesDirectory)\Documentation\%(RecursiveDir)%(Filename)%(Extension)')" />

    -->
    <!-- This item group must go after the copy so that any moved files are included -->
    <!--
    <ItemGroup>
      <ZipEliteEnterpriseSourceFiles
        Include="$(LocalExpertBinariesDirectory)\**\*.*"
        Exclude="@(SharedExclusions);@(EliteRoleExclusions);@(EliteDocuments)" />
    </ItemGroup>

    -->
    <!-- Create ZIP for Elite Enterprise ExpertSource -->
    <!--
    <MSBuild.Community.Tasks.Zip
      Files="@(ZipEliteEnterpriseSourceFiles)"
      ZipFileName="$(EliteEnterpriseZipFile)"
      WorkingDirectory="$(LocalExpertBinariesDirectory)"
      ParallelCompression="false" />

    -->
    <!-- Create ZIP for LicenseGenerator -->
    <!--
    <MSBuild.Community.Tasks.Zip
      Files="@(ZipLicenseGeneratorFiles)"
      ZipFileName="$(LicenseZipFile)"
      WorkingDirectory="$(LocalExpertBinariesDirectory)\ExpertSource\Internal\LicenseGenerator"
      ParallelCompression="false" />

    -->
    <!-- Create ZIP for RegistrationService -->
    <!--
    <MSBuild.Community.Tasks.Zip
      Files="@(ZipRegistrationServiceFiles)"
      ZipFileName="$(RegistrationZipFile)"
      WorkingDirectory="$(LocalExpertBinariesDirectory)\ExpertSource\Internal\RegistrationService"
      ParallelCompression="false" />

    <BuildStep
      Condition="('$(IsDesktopBuild)'!='true')"
      TeamFoundationServerUrl="$(TeamFoundationServerUrl)"
      BuildUri="$(BuildUri)"
      Id="$(BuildStepId)"
      Status="Succeeded" />

    <OnError ExecuteTargets="MarkBuildStepAsFailed" />-->
  </Target>
  
  
</Project>